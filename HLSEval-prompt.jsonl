{"task_id": "m2014_q4f", "problem_description": "\nImplement the following circuit in HLS. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4f(ap_uint<1> in1,  ap_uint<1> in2, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "step_one", "problem_description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).\n\n", "function_description": "\n#include <ap_int.h>\nvoid step_one(ap_uint<1>& one){\n    #pragma HLS INTERFACE ap_none port=one\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "ece241_2014_q1c", "problem_description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\n\n", "function_description": "\n#include <ap_int.h>\nvoid ece241_2014_q1c(ap_uint<8> a,  ap_uint<8>  b, ap_uint<8> s, ap_uint<1>& overflow){\n    #pragma HLS INTERFACE ap_none port=overflow\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "a2012_q1g", "problem_description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//x[1]x[2]\n//x[3]x[4]00  01 11  10  \n//00 | 1 | 0 | 0 | 1 |\n//01 | 0 | 0 | 0 | 0 |\n//11 | 1 | 1 | 1 | 0 |\n//10 | 1 | 1 | 0 | 1 |\n\n", "function_description": "\n#include <ap_int.h>\nvoid a2012_q1g (ap_uint<4> x, ap_uint<1>& f){\n    #pragma HLS INTERFACE ap_none port=f\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "a2012_q2b", "problem_description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write HLS code for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the HLS code by inspection assuming a one-hot encoding.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid a2012_q2b(ap_uint<6> y,  ap_uint<1>  w, ap_uint<1>& Y1, ap_uint<1>& Y3){\n    #pragma HLS INTERFACE ap_none port=Y1\n    #pragma HLS INTERFACE ap_none port=Y3\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "wire1", "problem_description": "Create a module with one input and one output that behaves like a wire.\n\n", "function_description": "\n#include <ap_int.h>\nvoid wire1(ap_uint<1> in, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit5", "problem_description": "This is a combinational circuit with 5 inputs(0xa,0xb,0xc,0xd, 0xe) and 1 output(0xq). Read the simulation below to determine what the circuit does, then implement it.\n0xa               0xb               0xc               0xd               0xe              0xq               \nx                  x                 x                x                  x                x              \nx                  x                 x                x                  x                x                \nx                  x                 x                x                  x                x               \n0xa               0xb                0               0xd                0xe              0xb                \n0xa               0xb                1               0xd                0xe              0xe              \n0xa               0xb                2               0xd                0xe              0xa                \n0xa               0xb                3               0xd                0xe              0xd               \n0xa               0xb                4               0xd                0xe              0xf                \n0xa               0xb                5               0xd                0xe              0xf                \n0xa               0xb                6               0xd                0xe              0xf                \n0xa               0xb                7               0xd                0xe              0xf                \n0xa               0xb                8               0xd                0xe              0xf              \n0xa               0xb                9               0xd                0xe              0xf               \n0xa               0xb               0xa              0xd                0xe              0xf               \n0xa               0xb               0xb              0xd                0xe              0xf                \n0xa               0xb               0xc              0xd                0xe              0xf               \n0xa               0xb               0xd              0xd                0xe              0xf                \n0xa               0xb               0xe              0xd                0xe              0xf                \n0xa               0xb               0xf              0xd                0xe              0xf\n", "function_description": "\n#include <ap_int.h>\nvoid circuit5(ap_uint<4> a,  ap_uint<4>  b, ap_uint<4> c , ap_uint<4> d, ap_uint<4> e. ap_uint<4>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit4","problem_description":  "This is a combinational circuit with 4 inputs(a,b,c,d) and 1 output(q). Read the simulation below to determine what the circuit does, then implement it.\n\na               b               c               d               q               \n0               0               0               0               0               \n0               0               0               0               0               \n0               0               0               0               0               \n0               0               0               0               0               \n0               0               0               1               0               \n0               0               1               0               1               \n0               0               1               1               1               \n0               1               0               0               1               \n0               1               0               1               1               \n0               1               1               0               1               \n0               1               1               1               1               \n1               0               0               0               0               \n1               0               0               1               0               \n1               0               1               0               1               \n1               0               1               1               1               \n1               1               0               0               1               \n1               1               0               1               1               \n1               1               1               0               1               \n1               1               1               1               1\n\n", "function_description": "\n#include <ap_int.h>\nvoid circuit4(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1> c , ap_uint<1> d, ap_uint<1>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "a7458", "problem_description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in HLS with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\n\n", "function_description": "\n#include <ap_int.h>\nvoid a7458(ap_uint<1> p1a, ap_uint<1> p1b, ap_uint<1> p1c, ap_uint<1> p1d, ap_uint<1> p1e, ap_uint<1> p1f , ap_uint<1>& p1y , ap_uint<1> p2a, ap_uint<1> p2b, ap_uint<1> p2c, ap_uint<1> p2d, ap_uint<1>& p2y){\n    #pragma HLS INTERFACE ap_none port=p1y\n    #pragma HLS INTERFACE ap_none port=p2y\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "truthtable1", "problem_description": "Create a combinational circuit that implements the truth table.\\n\\n// \nx3 | x2 | x1 | f\\n// \n 0 | 0 | 0 | 0\\n// \n 0 | 0 | 1 | 0\\n// \n 0 | 1 | 0 | 1\\n// \n 0 | 1 | 1 | 1\\n// \n 1 | 0 | 0 | 0\\n// \n 1 | 0 | 1 | 1\\n// \n 1 | 1 | 0 | 0\\n// \n 1 | 1 | 1 | 1\n \n", "function_description": "\n#include <ap_int.h>\nvoid truthtable1 (ap_uint<1> x3, ap_uint<1> x2, ap_uint<1> x1, ap_uint<1>& f){\n    #pragma HLS INTERFACE ap_none port=f\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector5", "problem_description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector5(ap_uint<1> a, ap_uint<1> b, ap_uint<1> c, ap_uint<1> d, ap_uint<1> e, ap_uint<25>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "andgate", "problem_description": "Create a module that implements an AND gate.\n\n", "function_description": "\n#include <ap_int.h>\nvoid andgate (ap_uint<1> a, ap_uint<1> b, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "always_case", "problem_description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\n\n", "function_description": "\n#include <ap_int.h>\nvoid always_case(ap_uint<3> sel, ap_uint<4> data0, ap_uint<4>  data1, ap_uint<4> data2 , ap_uint<4> data3 , ap_uint<4> data4 , ap_uint<4> data5 , ap_uint<4>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "fsm_onehot", "problem_description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \\\"(out1, out2)\\\"):\\n\\n// \nS0 (0, 0) --0--> S0\\n// \nS0 (0, 0) --1--> S1\\n// \nS1 (0, 0) --0--> S0\\n// \nS1 (0, 0) --1--> S2\\n// \nS2 (0, 0) --0--> S0\\n// \nS2 (0, 0) --1--> S3\\n// \nS3 (0, 0) --0--> S0\\n// \nS3 (0, 0) --1--> S4\\n// \nS4 (0, 0) --0--> S0\\n// \nS4 (0, 0) --1--> S5\\n// \nS5 (0, 0) --0--> S8\\n// \nS5 (0, 0) --1--> S6\\n// \nS6 (0, 0) --0--> S9\\n// \nS6 (0, 0) --1--> S7\\n// \nS7 (0, 1) --0--> S0\\n// \nS7 (0, 1) --1--> S7\\n// \nS8 (1, 0) --0--> S0\\n// \nS8 (1, 0) --1--> S1\\n// \nS9 (1, 1) --0--> S0\\n// \nS9 (1, 1) --1--> S1\\n\\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\\n\\n// Write HLS code implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\n Do not use nested if-else statements.\n", "function_description": "\n#include <ap_int.h>\nvoid fsm_onehot(ap_uint<1> in,ap_uint<10> state, ap_uint<10>& next_state,  ap_uint<1>& out1, ap_uint<1>& out2){\n    #pragma HLS INTERFACE ap_none port=next_state\n    #pragma HLS INTERFACE ap_none port=out1\n    #pragma HLS INTERFACE ap_none port=out2\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mux256to1v", "problem_description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mux256to1v(ap_uint<1024> in, ap_uint<8> sel, ap_uint<4>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4e", "problem_description": "Implement a 2-input NOR gate.\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4e(ap_uint<1> in1, ap_uint<1> in2, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "thermostat", "problem_description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid thermostat(ap_uint<1> mode, ap_uint<1>  too_cold, ap_uint<1> too_hot, ap_uint<1> fan_on, ap_uint<1>& heater, ap_uint<1>& aircon, ap_uint<1>& fan){\n    #pragma HLS INTERFACE ap_none port=heater\n    #pragma HLS INTERFACE ap_none port=aircon\n    #pragma HLS INTERFACE ap_none port=fan\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "gates4", "problem_description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \\n// \n(1) out_and: output of a 4-input AND gate. \\n// \n(2) out_or: output of a 4-input OR gate. \\n// \n(3) out_xor: output of a 4-input XOR gate.\\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid gates4(ap_uint<4> in, ap_uint<1>& out_and, ap_uint<1>& out_or, ap_uint<1>& out_xor){\n    #pragma HLS INTERFACE ap_none port=out_or\n    #pragma HLS INTERFACE ap_none port=out_xor\n     #pragma HLS INTERFACE ap_none port=out_and\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "norgate", "problem_description": "Create a module that implements a NOR gate.\n\n", "function_description": "\n#include <ap_int.h>\nvoid norgate(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q3", "problem_description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function.\n\\n//x[3]x[2]\\n// x[1]x[0]   \n00 01 11 10\\n//  \n00 | 0 | 0 | 0 | 0 |\\n//  \n01 | 0 | 1 | 1 | 0 |\\n//  \n11 | 1 | 1 | 1 | 0 |\\n//  \n10 | 1 | 1 | 0 | 0 |\\n//\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q3 (ap_uint<4> x, ap_uint<1>& f){\n    #pragma HLS INTERFACE ap_none port=f\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q6c", "problem_description": "Consider the state machine shown below:\nStates:\n    A\n    B\n    C\n    D\n    E\n    F\n\nInputs:\n    0\n    1\n\nTransitions:\n    A (0) -> B\n    A (1) -> A\n    B (0) -> C\n    B (1) -> D\n    C (0) -> E\n    C (1) -> D\n    D (0) -> F\n    D (1) -> A\n    E (0) -> E\n    E (1) -> D\n    F (0) -> C\n    F (1) -> D\n\nOutputs:\n    A: 0\n    B: 0\n    C: 0\n    D: 0\n    E: 1\n    F: 1\n\nResets into state A. For this part, assume that a one-hot code is used with the state assignment y[5:0] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\\n\\n// Write HLS code for the next-state signals Y2 and Y4 corresponding to signal y[1] and y[3]. Derive the logic equations by inspection assuming a one-hot encoding\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q6c(ap_uint<6> y,  ap_uint<1>  w, ap_uint<1>& Y2, ap_uint<1>& Y4){\n    #pragma HLS INTERFACE ap_none port=Y2\n    #pragma HLS INTERFACE ap_none port=Y4\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "fsm3onehot", "problem_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states.\n\nStates:\n    A\n    B\n    C\n    D\n\nInputs:\n    0\n    1\n\nTransitions:\n    A (0) -> A\n    A (1) -> B\n    B (0) -> C\n    B (1) -> B\n    C (0) -> A\n    C (1) -> D\n    D (0) -> C\n    D (1) -> B\n\nOutputs:\n    A: 0\n    B: 0\n    C: 0\n    D: 1\n  \nUse the following one-hot state encoding: \nA=0b0001, B=0b0010, C=0b0100, D=0b1000. \nDerive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n  \n", "function_description": "\n#include <ap_int.h>\nvoid fsm3onehot(ap_uint<1> in, ap_uint<4> state, ap_uint<4>& next_state, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=next_state\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "ece241_2014_q3", "problem_description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd 00   01  11  10  \n//00 | 0 | 0 | 0 | 1 |\n//01 | 1 | 0 | 0 | 0 |\n//11 | 1 | 0 | 1 | 1 |\n//10 | 1 | 0 | 0 | 1 |\n\n//Consider a block diagram with inputs 'c' and 'd' going into a module called \"ece241_2014_q3\". This \"ece241_2014_q3\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux_in takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in HLS just the portion labelled \"ece241_2014_q3\", such that the entire circuit (including the 4-to-1 mux) implements the K-map. Do not add any additional functions.\n\n", "function_description": "\n#include <ap_int.h>\nvoid ece241_2014_q3 (ap_uint<1> c, ap_uint<1> d, ap_uint<4>& mux_in){\n    #pragma HLS INTERFACE ap_none port=mux_in\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "a7420", "problem_description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid a7420(ap_uint<1> p1a,  ap_uint<1>  p1b, ap_uint<1> p1c, ap_uint<1> p1d, ap_uint<1>& p1y, ap_uint<1> p2a, ap_uint<1> p2b, ap_uint<1> p2c, ap_uint<1> p2d, ap_uint<1>& p2y){\n    #pragma HLS INTERFACE ap_none port=p1y\n    #pragma HLS INTERFACE ap_none port=p2y\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mux9to1v", "problem_description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mux9to1v(ap_uint<16> a, ap_uint<16> b, ap_uint<16> c, ap_uint<16> d, ap_uint<16> e, ap_uint<16> f, ap_uint<16> g, ap_uint<16> h, ap_uint<16> i,  ap_uint<4> sel, ap_uint<16>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector2", "problem_description": "Build a circuit that reverses the byte order of a 32-bit vector.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector2(ap_uint<32> in,  ap_uint<32>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4i", "problem_description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4i(ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "zero", "problem_description": "\nBuild a circuit that always outputs a LOW.\n\n", "function_description": "\n#include <ap_int.h>\nvoid zero(ap_uint<1>& zero){\n    #pragma HLS INTERFACE ap_none port=zero\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "kmap4", "problem_description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\n\n", "function_description": "\n#include <ap_int.h>\nvoid kmap4(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "fadd", "problem_description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\n\n", "function_description": "\n#include <ap_int.h>\nvoid fadd (ap_uint<1> a, ap_uint<1> b, ap_uint<1> cin, ap_uint<1>& cout, ap_uint<1>& sum){\n    #pragma HLS INTERFACE ap_none port=cout\n    #pragma HLS INTERFACE ap_none port=sum\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4g", "problem_description": "Implement  the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4g (ap_uint<1> in1, ap_uint<1> in2, ap_uint<1> in3, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "gates", "problem_description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \\n// \n(1) out_and: a and b \\n// \n(2) out_or: a or b \\n// \n(3) out_xor: a xor b \\n// \n(4) out_nand: a nand b \\n// \n(5) out_nor: a nor b \\n// \n(6) out_xnor: a xnor b \\n// \n(7) out_anotb: a and-not b\n\n", "function_description": "\n#include <ap_int.h>\nvoid gates(ap_uint<1> a, ap_uint<1> b, ap_uint<1>& out_and, ap_uint<1>& out_or, ap_uint<1>& out_xor, ap_uint<1>& out_nand, ap_uint<1>& out_nor, ap_uint<1>& out_xnor, ap_uint<1>& out_anotb){\n    #pragma HLS INTERFACE ap_none port=out_and\n    #pragma HLS INTERFACE ap_none port=out_or\n    #pragma HLS INTERFACE ap_none port=out_xor\n    #pragma HLS INTERFACE ap_none port=out_nand\n    #pragma HLS INTERFACE ap_none port=out_nor\n    #pragma HLS INTERFACE ap_none port=out_xnor\n    #pragma HLS INTERFACE ap_none port=out_anotb\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "conditional", "problem_description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b)\n\n", "function_description": "\n#include <ap_int.h>\nvoid conditional(ap_uint<8> a, ap_uint<8> b, ap_uint<8> c, ap_uint<8> d, ap_uint<8>& min){\n    #pragma HLS INTERFACE ap_none port=min\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mt2015_q4a", "problem_description": "Implement the boolean function z = (x^y) & x.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mt2015_q4a(ap_uint<1> x,  ap_uint<1> y, ap_uint<1>& z ){\n    #pragma HLS INTERFACE ap_none port=z\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "reduction", "problem_description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits. Do not use any loops.\n\n", "function_description": "\n#include <ap_int.h>\nvoid reduction (ap_uint<8> in, ap_uint<1>& parity){\n    #pragma HLS INTERFACE ap_none port=parity\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "always_case2", "problem_description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first logic-1 bit in the vector. For example, a 4-bit priority encoder given the input 4'b1101 would output 2'd0, because the first input bit that is at logic-1 is at position 0. Build a priority encoder with 4-bit input. For this problem, if none of the input bits are high (i.e., input is zero), output is zero. Note that a 4-bit number has 16 possible combinations. Do not use any loops.\n\n", "function_description": "\n#include <ap_int.h>\nvoid always_case2(ap_uint<4> in, ap_uint<2>& pos){\n    #pragma HLS INTERFACE ap_none port=pos\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit1", "problem_description": "This is a combinational circuit with 2 inputs(a,b) and 1 output(q). Read the simulation below to determine what the circuit does, then implement it.\n\na               b               q               \n0               0               0                \n0               0               0              \n0               0               0         \n0               0               0              \n0               0               0               \n0               1               0             \n0               1               0              \n1               0               0               \n1               0               0               \n1               1               1                \n1               1               1                \n0               0               0               \n0               0               0               \n0               1               0            \n0               1               0              \n1               0               0                \n1               0               0               \n1               1               1               \n1               1               1             \n", "function_description": "\n#include <ap_int.h>\nvoid circuit1(ap_uint<1> a, ap_uint<1> b, ap_uint<1>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4h", "problem_description": "The module assigns the output port to the same value as the input port combinationally.\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4h(ap_uint<1> in, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q6b", "problem_description": "Consider the state machine shown below:\\n\nStates:\n    A\n    B\n    C\n    D\n    E\n    F\n\nInputs:\n    0\n    1\n\nTransitions:\n    A (0) -> B\n    A (1) -> A\n    B (0) -> C\n    B (1) -> D\n    C (0) -> E\n    C (1) -> D\n    D (0) -> F\n    D (1) -> A\n    E (0) -> E\n    E (1) -> D\n    F (0) -> C\n    F (1) -> D\n\nOutputs:\n    A: 0\n    B: 0\n    C: 0\n    D: 0\n    E: 1\n    F: 1\n\nFor this part, assume that the following code is used with the state assignments y[2:0] = 000, 001, 010, 011, 100, 101 for states A, B, C, D, E, F, respectively.\nWrite HLS code for the next-state signal Y1 corresponding to signal y[1]. Derive the logic equation by inspection assuming the given encoding.\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q6b(ap_uint<3> y, ap_uint<1> w, ap_uint<1>& Y1){\n    #pragma HLS INTERFACE ap_none port=Y1\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "wire4", "problem_description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:\n a -> w \\n// ;\n b -> x;\n b -> y;\n c -> z.\n \n", "function_description": "\n#include <ap_int.h>\nvoid wire4(ap_uint<1> a, ap_uint<1> b, ap_uint<1> c, ap_uint<1>& w, ap_uint<1>& x, ap_uint<1>& y , ap_uint<1>& z){\n    #pragma HLS INTERFACE ap_none port=w\n    #pragma HLS INTERFACE ap_none port=x\n    #pragma HLS INTERFACE ap_none port=y\n    #pragma HLS INTERFACE ap_none port=z\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mt2015_eq2", "problem_description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mt2015_eq2(ap_uint<2> A, ap_uint<2> B, ap_uint<1>& z){\n    #pragma HLS INTERFACE ap_none port=z\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "popcount255", "problem_description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector. Do not use any loops.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid popcount255(ap_uint<255> in,  ap_uint<8>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vectorgates", "problem_description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vectorgates(ap_uint<3> a, ap_uint<3> b, ap_uint<3>& out_or_bitwise, ap_uint<1>& out_or_logical, ap_uint<6>& out_not){\n    #pragma HLS INTERFACE ap_none port=out_or_bitwise\n    #pragma HLS INTERFACE ap_none port=out_or_logical\n    #pragma HLS INTERFACE ap_none port=out_not\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector0", "problem_description": "\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector0(ap_uint<3> vec,  ap_uint<3>& outv, ap_uint<1>& o2, ap_uint<1>& o1, ap_uint<1>& o0){\n    #pragma HLS INTERFACE ap_none port=outv\n    #pragma HLS INTERFACE ap_none port=o2\n    #pragma HLS INTERFACE ap_none port=o1\n    #pragma HLS INTERFACE ap_none port=o0\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "fsm3comb", "problem_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. \n\nStates:\n    A\n    B\n    C\n    D\n\nInputs:\n    0\n    1\n\nTransitions:\n    A (0) -> A\n    A (1) -> B\n    B (0) -> C\n    B (1) -> B\n    C (0) -> A\n    C (1) -> D\n    D (0) -> C\n    D (1) -> B\n\nOutputs:\n    A: 0\n    B: 0\n    C: 0\n    D: 1\n    \nUse the following state encoding: A=0b00, B=0b01, C=0b10, D=0b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n\n", "function_description": "\n#include <ap_int.h>\nvoid fsm3comb (ap_uint<1> in, ap_uint<2> state, ap_uint<2>& next_state, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=next_state\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return \n    <FILL>\n}        \n"}
{"task_id": "kmap2", "problem_description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\n\n", "function_description": "\n#include <ap_int.h>\nvoid kmap2 (ap_uint<1> a, ap_uint<1> b, ap_uint<1>  c,  ap_uint<1>  d,  ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4a", "problem_description": "Implement a D latch.\n\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4a(ap_uint<1> d, ap_uint<1> ena, ap_uint<1>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mt2015_q4b", "problem_description": "The module can be described by the following simulation waveform where x and y are inputs and z is the output: \\n\\n// \ntime            x               y               z               \\n// \n0ns             0               0               1               \\n// \n5ns             0               0               1               \\n// \n10ns            0               0               1               \\n// \n15ns            0               0               1               \\n// \n20ns            0               0               1               \\n// \n25ns            1               0               0               \\n// \n30ns            1               0               0               \\n// \n35ns            0               1               0               \\n// \n40ns            0               1               0               \\n// \n45ns            1               1               1               \\n// \n50ns            1               1               1               \\n// \n55ns            0               0               1               \\n// \n60ns            0               1               0               \\n// \n65ns            0               1               0               \\n// \n70ns            1               1               1               \\n// \n75ns            0               1               0               \\n// \n80ns            0               1               0               \\n// \n85ns            0               1               0               \\n// \n90ns            1               0               0                               \n\n", "function_description": "\n#include <ap_int.h>\nvoid mt2015_q4b (ap_uint<1> x, ap_uint<1> y, ap_uint<1>& z){\n    #pragma HLS INTERFACE ap_none port=z\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mux2to1v", "problem_description": "\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mux2to1v(ap_uint<100> a, ap_uint<100> b, ap_uint<1> sel, ap_uint<100>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector4", "problem_description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 0b0101 (5) to 8 bits results in 0b00000101 (5), while sign-extending 0b1101 (-3) to 8 bits results in 0b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector4(ap_uint<8> in, ap_uint<32>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "notgate", "problem_description": "Create a module that implements a NOT gate.\n\n", "function_description": "\n#include <ap_int.h>\nvoid notgate(ap_uint<1> in, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "m2014_q4j", "problem_description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.\n Do not use for loop.\n", "function_description": "\n#include <ap_int.h>\nvoid m2014_q4j(ap_uint<4> x,  ap_uint<4>  y, ap_uint<5>& sum){\n    #pragma HLS INTERFACE ap_none port=sum\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "always_nolatches", "problem_description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n\\n// Scancode[15:0] | Arrow key\n\\n//       16'he06b | left arrow\n\\n//       16'he072 | down arrow\n\\n//       16'he074 | right arrow\n\\n//       16'he075 | up arrow\n\\n//  Anything else | none\n\\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\\n\\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid always_nolatches(ap_uint<16> scancode,  ap_uint<3>&  left, ap_uint<1>& down, ap_uint<1>& right, ap_uint<1>& up){\n    #pragma HLS INTERFACE ap_none port=left\n    #pragma HLS INTERFACE ap_none port=down\n    #pragma HLS INTERFACE ap_none port=right\n    #pragma HLS INTERFACE ap_none port=up\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mux2to1", "problem_description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\n\n", "function_description": "\n#include <ap_int.h>\nvoid mux2to1(ap_uint<1> a, ap_uint<1> b, ap_uint<1> sel, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "popcount3", "problem_description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\n Do not use for loop.\n", "function_description": "\n#include <ap_int.h>\nvoid popcount3(ap_uint<3> in,ap_uint<2>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "ece241_2013_q2", "problem_description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 at output when any one of 2, 7, 15 appears on the inputs, and a logic-0 at output when any one of 0, 1, 4, 5, 6, 9, 10, 13, 14 appears on the inputs.  The output is allowed to be at either logic-0 or logic-1 when any one of 3, 8, 11, 12 appears on the input. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid ece241_2013_q2(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& out_sop, ap_uint<1>& out_pos){\n    #pragma HLS INTERFACE ap_none port=out_sop\n    #pragma HLS INTERFACE ap_none port=out_pos\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector100r", "problem_description": "Given a 100-bit input vector [99:0], reverse its bit ordering. Do not use any loops.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector100r(ap_uint<100> in, ap_uint<100>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "hadd", "problem_description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\n\n", "function_description": "\n#include <ap_int.h>\nvoid gates100 (ap_uint<1> a, ap_uint<1> b, ap_uint<1>& sum, ap_uint<1>& cout){\n    #pragma HLS INTERFACE ap_none port=sum\n    #pragma HLS INTERFACE ap_none port=cout\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "always_casez", "problem_description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\n\n", "function_description": "\n#include <ap_int.h>\nvoid always_casez(ap_uint<8> in,  ap_uint<3>&  pos){\n    #pragma HLS INTERFACE ap_none port=pos\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mux256to1", "problem_description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid mux256to1(ap_uint<256> in,  ap_uint<8>  sel, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "mt2015_q4", "problem_description": "Function A returns the boolean function  z = (x^y) & x.\nModule A implements the boolean function z = (x^y) & x.\nFunction B can be described by the following.\n// Module B can be described by the following simulation waveform: \n\n//time            x               y               z               \n//0ns             0               0               1               \n//5ns             0               0               1               \n//10ns            0               0               1               \n//15ns            0               0               1               \n//20ns            0               0               1               \n//25ns            1               0               0               \n//30ns            1               0               0               \n//35ns            0               1               0               \n//40ns            0               1               0               \n//45ns            1               1               1               \n//50ns            1               1               1               \n//55ns            0               0               1               \n//60ns            0               1               0               \n//65ns            0               1               0               \n//70ns            1               1               1               \n//75ns            0               1               0               \n//80ns            0               1               0               \n//85ns            0               1               0               \n//90ns            1               0               0               \n\n\n// Now consider a top-level function mt2015_q4 that uses two A functions and two B functions. The first input of all four functions is connect to input 'x', and the second input of all four functions is connected to 'y'. The output of the first A function is connected to a two-input OR, along with the output of the first B function. The second pair of A and B functions is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid A(ap_uint<1> x, ap_uint<1> y, ap_uint<1>& z){\n   <FILL>\n}\nvoid B(ap_uint<1> x, ap_uint<1> y, ap_uint<1>& z){\n   <FILL>\n}\nvoid mt2015_q4(ap_uint<1> x, ap_uint<1> y, ap_uint<1>& z){\n    #pragma HLS INTERFACE ap_none port=z\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n\n"}
{"task_id": "wire_decl", "problem_description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\n\n", "function_description": "\n#include <ap_int.h>\nvoid wire_decl(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& out,  ap_uint<1>& out_n){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_none port=out_n\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "kmap3", "problem_description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//ab\n//  cd01 00 10 11\n//00 | d | 0 | 1 | 1 |\n//01 | 0 | 0 | d | d |\n//11 | 0 | 1 | 1 | 1 |\n//10 | 0 | 1 | 1 | 1 |\n  \n", "function_description": "\n#include <ap_int.h>\nvoid kmap3(ap_uint<1> a, ap_uint<1> b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "review2015_fsmonehot", "problem_description": "Consider the state machine shown below:\n\nStates:\nS    \nS1   \nS11  \nS110 \nB0   \nB1   \nB2  \nB3   \nCount\nWait \n\nState Transition Table:\n\nCurrent State    Input Condition       Next State\nS                d = 0                 S\nS                d = 1                 S1\nS1               d = 0                 S\nS1               d = 1                 S11\nS11              d = 0                 S110\nS11              d = 1                 S11\nS110             d = 0                 S\nS110             d = 1                 B0\nB0               (always)              B1\nB1               (always)              B2\nB2               (always)              B3\nB3               (always)              Count\nCount            done_counting = 0     Count\nCount            done_counting = 1     Wait\nWait             ack = 0               Wait\nWait             ack = 1               S\n\nOutput Logic:\n\nState      Output\nB0         shift_ena = 1\nB1         shift_ena = 1\nB2         shift_ena = 1\nB3         shift_ena = 1\nCount      counting = 1\nWait       done = 1\n\nAt reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (0b0000000001, 0b0000000010, 0b0000000100, 0b0000001000, 0b0000010000, 0b0000100000, 0b0001000000, 0b0010000000, 0b0100000000 , 0b1000000000)\n", "function_description": "\n#include <ap_int.h>\nvoid review2015_fsmonehot(ap_uint<1> d,  ap_uint<1>  done_counting, ap_uint<1> ack, ap_uint<10> state, ap_uint<1>& B3_next, ap_uint<1>& S_next, ap_uint<1>& S1_next, ap_uint<1>& Count_next, ap_uint<1>& Wait_next,ap_uint<1>& done, ap_uint<1>& counting, ap_uint<1>&  shift_ena){\n    #pragma HLS INTERFACE ap_none port=B3_next\n    #pragma HLS INTERFACE ap_none port=S_next\n    #pragma HLS INTERFACE ap_none port=S1_next\n    #pragma HLS INTERFACE ap_none port=Count_next\n    #pragma HLS INTERFACE ap_none port=Wait_next\n    #pragma HLS INTERFACE ap_none port=done\n    #pragma HLS INTERFACE ap_none port=counting\n    #pragma HLS INTERFACE ap_none port=shift_ena\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit3", "problem_description": "This is a combinational circuit with 4 inputs(a,b,c,d) and 1 output(q). Read the simulation below to determine what the circuit does, then implement it.\na               b               c               d               q                \n0               0               0               0               0               \n0               0               0               0               0               \n0               0               0               0               0                \n0               0               0               0               0             \n0               0               0               1               0                \n0               0               1               0               0               \n0               0               1               1               0                \n0               1               0               0               0               \n0               1               0               1               1              \n0               1               1               1               1               \n1               0               0               0               0               \n1               0               0               1               1               \n1               0               1               0               1                \n1               0               1               1               1            \n1               1               0               0               0                \n1               1               0               1               1               \n1               1               1               0               1               \n1               1               1               1               1    \n", "function_description": "\n#include <ap_int.h>\nvoid circuit3(ap_uint<1> a,  ap_uint<1>  b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vectorr", "problem_description": "Given an 8-bit input vector [7:0], reverse its bit ordering.Do not use any loops. Do not use functions of input variable.\n\n", "function_description": "\n#include <ap_int.h>\nvoid vectorr(ap_uint<8> in, ap_uint<8>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "xnorgate", "problem_description": "Create a module that implements an XNOR gate.\n\n", "function_description": "\n#include <ap_int.h>\nvoid xnorgate(ap_uint<1> a, ap_uint<1> b, ap_uint<1>& out){\n    #pragma HLS INTERFACE ap_none port=out\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "gates100", "problem_description": "Build a combinational circuit with 100 inputs, in[99:0]. Do not use for loop. There are 3 outputs: \\n// \n(1) out_and: output of a 100-input AND gate. \\n// \n(2) out_or: output of a 100-input OR gate. \\n// \n(3) out_xor: output of a 100-input XOR gate.\\n\\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid gates100 (ap_uint<100> in, ap_uint<1>& out_and, ap_uint<1>& out_or, ap_uint<1>& out_xor){\n    #pragma HLS INTERFACE ap_none port=out_and\n    #pragma HLS INTERFACE ap_none port=out_or\n    #pragma HLS INTERFACE ap_none port=out_xor\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "vector1", "problem_description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid vector1(ap_uint<16> in,  ap_uint<8>&  out_hi, ap_uint<8>& out_lo ){\n    #pragma HLS INTERFACE ap_none port=out_hi\n    #pragma HLS INTERFACE ap_none port=out_lo\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "gatesv", "problem_description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'.Since in[0] has no neighbour to the right, therefore out_any[0] = in[0]. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0]. For example, out_different[2] should indicate if in[2] is different from in[3].\n\n", "function_description": "\n#include <ap_int.h>\nvoid gatesv(ap_uint<4> in,  ap_uint<3>& out_both, ap_uint<4>& out_any, ap_uint<4>& out_different){\n    #pragma HLS INTERFACE ap_none port=out_both\n    #pragma HLS INTERFACE ap_none port=out_any\n    #pragma HLS INTERFACE ap_none port=out_different\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit6", "problem_description": "This is a combinational circuit with 1 input(a) and 1 output(q). Read the simulation below to determine what the circuit does, then implement it.\n\na                  q            \nx                  x             \nx                  x            \nx                  x             \n0               1232         \n1               aee0             \n2               27d4            \n3               5a0e            \n4               2066            \n5               64ce            \n6               c526          \n7               2f19            \n0               1232            \n1               aee0            \n2               27d4            \n4               2066            \n1               aee0            \n1               aee0             \n3               5a0e            \n5               64ce            \n", "function_description": "\n#include <ap_int.h>\nvoid circuit6(ap_uint<3> a, ap_uint<16>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "gatesv100", "problem_description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \\n// \n(1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. \nFor example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \\n// \n(2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. \nFor example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \\n// \n(3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. \nFor example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\\n\n\n", "function_description": "\n#include <ap_int.h>\nvoid gatesv100(ap_uint<100> in, ap_uint<99>& out_both, ap_uint<100>& out_any, ap_uint<100>& out_different){\n    #pragma HLS INTERFACE ap_none port=out_both\n    #pragma HLS INTERFACE ap_none port=out_any\n    #pragma HLS INTERFACE ap_none port=out_different\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "circuit2", "problem_description": "This is a combinational circuit with 4 inputs(a,b,c,d) and 1 output(q). Read the simulation below to determine what the circuit does, then implement it.\n\na               b               c               d               q               \n0               0               0               0               1               \n0               0               0               0               1               \n0               0               0               0               1               \n0               0               0               0               1               \n0               0               0               1               0               \n0               0               1               0               0               \n0               0               1               1               1               \n0               1               0               0               0               \n0               1               0               1               1               \n0               1               1               0               1               \n0               1               1               1               0               \n1               0               0               0               0               \n1               0               0               1               1               \n1               0               1               0               1               \n1               0               1               1               0               \n1               1               0               0               1               \n1               1               0               1               0               \n1               1               1               0               0               \n1               1               1               1               1\n\n", "function_description": "\n#include <ap_int.h>\nvoid circuit2 (ap_uint<1> a, ap_uint<1> b, ap_uint<1> c, ap_uint<1> d, ap_uint<1>& q){\n    #pragma HLS INTERFACE ap_none port=q\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
{"task_id": "always_if", "problem_description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement\n\n", "function_description": "\n#include <ap_int.h>\nvoid always_if(ap_uint<1> a, ap_uint<1> b,  ap_uint<4> sel_b1, ap_uint<4> sel_b2, ap_uint<4>& out_assign, ap_uint<4>& out_always){\n    #pragma HLS INTERFACE ap_none port=out_assign\n    #pragma HLS INTERFACE ap_none port=out_always\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    <FILL>\n}\n"}
