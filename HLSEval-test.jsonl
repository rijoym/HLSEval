{"task_id": "circuit3", "prompt": "module circuit3 (\n        a,\n        b,\n        c,\n        d,\n        q\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] q;", "canonical_solution": "wire   [0:0] ret_V_6_fu_65_p2;\nwire   [0:0] and_ln1497_fu_77_p2;\nwire   [0:0] ret_V_7_fu_71_p2;\nwire   [0:0] ret_V_8_fu_83_p2;\nwire   [0:0] ret_V_9_fu_89_p2;\nwire   [0:0] ret_V_10_fu_95_p2;\nwire   [0:0] or_ln1498_1_fu_107_p2;\nwire   [0:0] or_ln1498_fu_101_p2;\n\nassign and_ln1497_fu_77_p2 = (d & c);\n\nassign or_ln1498_1_fu_107_p2 = (ret_V_9_fu_89_p2 | ret_V_10_fu_95_p2);\n\nassign or_ln1498_fu_101_p2 = (ret_V_8_fu_83_p2 | ret_V_7_fu_71_p2);\n\nassign ret_V_10_fu_95_p2 = (ret_V_6_fu_65_p2 & d);\n\nassign ret_V_6_fu_65_p2 = (b & a);\n\nassign ret_V_7_fu_71_p2 = (ret_V_6_fu_65_p2 & c);\n\nassign ret_V_8_fu_83_p2 = (b & and_ln1497_fu_77_p2);\n\nassign ret_V_9_fu_89_p2 = (and_ln1497_fu_77_p2 & a);\n\nassign q = (or_ln1498_fu_101_p2 | or_ln1498_1_fu_107_p2);\n\nendmodule //circuit3", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) & (c|d);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,c,d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b,c,d} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b,c,d} <= 0;\n\t\t\trepeat(18) @(posedge clk, negedge clk) {a,b,c,d} <= {a,b,c,d} + 1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit3 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4j", "prompt": "module m2014_q4j (\n        x,\n        y,\n        sum\n);\n\n\ninput  [3:0] x;\ninput  [3:0] y;\noutput  [4:0] sum;", "canonical_solution": "wire   [2:0] empty_6_fu_65_p1;\nwire   [2:0] empty_fu_61_p1;\nwire   [1:0] trunc_ln6_3_fu_81_p1;\nwire   [1:0] trunc_ln6_2_fu_77_p1;\nwire   [0:0] trunc_ln6_1_fu_73_p1;\nwire   [0:0] trunc_ln6_fu_69_p1;\nwire   [1:0] xor_ln301_1_fu_97_p2;\nwire   [0:0] tmp_fu_127_p3;\nwire   [0:0] and_ln1350_fu_121_p2;\nwire   [1:0] and_ln10_fu_115_p2;\nwire   [0:0] and_ln1349_1_fu_149_p2;\nwire   [0:0] tmp_1_fu_141_p3;\nwire   [2:0] xor_ln301_fu_91_p2;\nwire   [0:0] tmp_2_fu_161_p3;\nwire   [0:0] carry_V_fu_155_p2;\nwire   [2:0] and_ln8_fu_109_p2;\nwire   [0:0] and_ln1349_fu_175_p2;\nwire   [0:0] tmp_3_fu_181_p3;\nwire   [3:0] xor_ln6_fu_85_p2;\nwire   [0:0] tmp_4_fu_195_p3;\nwire   [0:0] carry_V_1_fu_189_p2;\nwire   [0:0] xor4_V_fu_203_p2;\nwire   [0:0] xor3_V_fu_169_p2;\nwire   [0:0] xor2_fu_135_p2;\nwire   [0:0] xor1_V_fu_103_p2;\n\nassign and_ln10_fu_115_p2 = (trunc_ln6_3_fu_81_p1 & trunc_ln6_2_fu_77_p1);\n\nassign and_ln1349_1_fu_149_p2 = (tmp_fu_127_p3 & and_ln1350_fu_121_p2);\n\nassign and_ln1349_fu_175_p2 = (tmp_2_fu_161_p3 & carry_V_fu_155_p2);\n\nassign and_ln1350_fu_121_p2 = (trunc_ln6_fu_69_p1 & trunc_ln6_1_fu_73_p1);\n\nassign and_ln8_fu_109_p2 = (empty_fu_61_p1 & empty_6_fu_65_p1);\n\nassign carry_V_1_fu_189_p2 = (tmp_3_fu_181_p3 | and_ln1349_fu_175_p2);\n\nassign carry_V_fu_155_p2 = (tmp_1_fu_141_p3 | and_ln1349_1_fu_149_p2);\n\nassign empty_6_fu_65_p1 = y[2:0];\n\nassign empty_fu_61_p1 = x[2:0];\n\nassign sum = {{{{{carry_V_1_fu_189_p2}, {xor4_V_fu_203_p2}}, {xor3_V_fu_169_p2}}, {xor2_fu_135_p2}}, {xor1_V_fu_103_p2}};\n\nassign tmp_1_fu_141_p3 = and_ln10_fu_115_p2[32'd1];\n\nassign tmp_2_fu_161_p3 = xor_ln301_fu_91_p2[32'd2];\n\nassign tmp_3_fu_181_p3 = and_ln8_fu_109_p2[32'd2];\n\nassign tmp_4_fu_195_p3 = xor_ln6_fu_85_p2[32'd3];\n\nassign tmp_fu_127_p3 = xor_ln301_1_fu_97_p2[32'd1];\n\nassign trunc_ln6_1_fu_73_p1 = y[0:0];\n\nassign trunc_ln6_2_fu_77_p1 = x[1:0];\n\nassign trunc_ln6_3_fu_81_p1 = y[1:0];\n\nassign trunc_ln6_fu_69_p1 = x[0:0];\n\nassign xor1_V_fu_103_p2 = (trunc_ln6_fu_69_p1 ^ trunc_ln6_1_fu_73_p1);\n\nassign xor2_fu_135_p2 = (tmp_fu_127_p3 ^ and_ln1350_fu_121_p2);\n\nassign xor3_V_fu_169_p2 = (tmp_2_fu_161_p3 ^ carry_V_fu_155_p2);\n\nassign xor4_V_fu_203_p2 = (tmp_4_fu_195_p3 ^ carry_V_1_fu_189_p2);\n\nassign xor_ln301_1_fu_97_p2 = (trunc_ln6_3_fu_81_p1 ^ trunc_ln6_2_fu_77_p1);\n\nassign xor_ln301_fu_91_p2 = (empty_fu_61_p1 ^ empty_6_fu_65_p1);\n\nassign xor_ln6_fu_85_p2 = (y ^ x);\n\nendmodule //m2014_q4j", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y;\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [3:0] x,y\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{x,y} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_sum;\n\t\tint errortime_sum;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] x;\n\tlogic [3:0] y;\n\tlogic [4:0] sum_ref;\n\tlogic [4:0] sum_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.x,\n\t\t.y,\n\t\t.sum(sum_ref) );\n\t\t\n\tm2014_q4j top_module1 (\n\t\t.x,\n\t\t.y,\n\t\t.sum(sum_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_sum) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"sum\", stats1.errors_sum, stats1.errortime_sum);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"sum\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { sum_ref } === ( { sum_ref } ^ { sum_dut } ^ { sum_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (sum_ref !== ( sum_ref ^ sum_dut ^ sum_ref ))\n\t\tbegin if (stats1.errors_sum == 0) stats1.errortime_sum = $time;\n\t\t\tstats1.errors_sum = stats1.errors_sum+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "always_case2", "prompt": "module always_case2 (\n        in_r,\n        pos_r\n);\n\n\ninput  [3:0] in_r;\noutput  [1:0] pos_r;", "canonical_solution": "reg[1:0] pos_r;\n\nwire   [3:0] in_r_read_read_fu_44_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if (((in_r_read_read_fu_44_p2 == 4'd1) | (~(in_r_read_read_fu_44_p2 == 4'd8) & ~(in_r_read_read_fu_44_p2 == 4'd1) & ~(in_r_read_read_fu_44_p2 == 4'd2) & ~(in_r_read_read_fu_44_p2 == 4'd4)))) begin\n        pos_r = 2'd0;\n    end else if ((in_r_read_read_fu_44_p2 == 4'd2)) begin\n        pos_r = 2'd1;\n    end else if ((in_r_read_read_fu_44_p2 == 4'd4)) begin\n        pos_r = 2'd2;\n    end else if ((in_r_read_read_fu_44_p2 == 4'd8)) begin\n        pos_r = 2'd3;\n    end else begin\n        pos_r = 'bx;\n    end\nend\n\nassign in_r_read_read_fu_44_p2 = in_r;\n\nendmodule //always_case2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [3:0] in, \n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start(\"Priority encoder\");\n\t\t\t@(posedge clk) in <= 4'h1;\n\t\t\trepeat(4) @(posedge clk) in <= in << 1;\n\t\t\tin <= 0;\n\t\t\trepeat(16) @(posedge clk) in <= in + 1;\n\t\t@(negedge clk) wavedrom_stop();\n\n\t\trepeat(50) @(posedge clk, negedge clk) begin\n\t\t\tin <= $urandom;\n\t\tend\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_pos;\n\t\tint errortime_pos;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] in;\n\tlogic [1:0] pos_ref;\n\tlogic [1:0] pos_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.pos(pos_ref) );\n\t\t\n\talways_case2 top_module1 (\n\t\t.in_r(in),\n\t\t.pos_r(pos_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_pos) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"pos\", stats1.errors_pos, stats1.errortime_pos);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"pos\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { pos_ref } === ( { pos_ref } ^ { pos_dut } ^ { pos_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (pos_ref !== ( pos_ref ^ pos_dut ^ pos_ref ))\n\t\tbegin if (stats1.errors_pos == 0) stats1.errortime_pos = $time;\n\t\t\tstats1.errors_pos = stats1.errors_pos+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "circuit1", "prompt": "module circuit1 (\n        a,\n        b,\n        q\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] q;", "canonical_solution": "assign q = (b & a);\n\nendmodule //circuit1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b} <= 0;\n\t\t\trepeat(8) @(posedge clk) {a,b} <= {a,b} + 1;\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit1 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "wire1", "prompt": "module wire1 (\n        in_r,\n        out_r\n);\n\n\ninput  [0:0] in_r;\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = in_r;\n\nendmodule //wire1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start(\"Output should follow input\");\n\t\trepeat(20) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tin <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\twire1 top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vector2", "prompt": "module vector2 (\n        in_r,\n        out_r\n);\n\n\ninput  [31:0] in_r;\noutput  [31:0] out_r;", "canonical_solution": "wire   [7:0] trunc_ln628_fu_87_p1;\nwire   [7:0] tmp_1_fu_77_p4;\nwire   [7:0] tmp_s_fu_67_p4;\nwire   [7:0] tmp2_fu_57_p4;\n\nassign tmp2_fu_57_p4 = {{in_r[31:24]}};\n\nassign tmp_1_fu_77_p4 = {{in_r[15:8]}};\n\nassign tmp_s_fu_67_p4 = {{in_r[23:16]}};\n\nassign trunc_ln628_fu_87_p1 = in_r[7:0];\n\nassign out_r = {{{{trunc_ln628_fu_87_p1}, {tmp_1_fu_77_p4}}, {tmp_s_fu_67_p4}}, {tmp2_fu_57_p4}};\n\nendmodule //vector2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\t\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [31:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start(\"Random inputs\");\n\t\trepeat(10) @(posedge clk, negedge clk) \n\t\t\tin <= $random;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [31:0] in;\n\tlogic [31:0] out_ref;\n\tlogic [31:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tvector2 top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "fsm_onehot", "prompt": "module fsm_onehot (\n        in_r,\n        state,\n        next_state,\n        out1,\n        out2\n);\n\n\ninput  [0:0] in_r;\ninput  [9:0] state;\noutput  [9:0] next_state;\noutput  [0:0] out1;\noutput  [0:0] out2;", "canonical_solution": "wire   [0:0] and_ln1497_5_fu_189_p2;\nwire   [0:0] icmp_ln1019_fu_93_p2;\nwire   [0:0] xor_ln901_fu_153_p2;\nwire   [0:0] icmp_ln1019_1_fu_99_p2;\nwire   [0:0] icmp_ln1019_2_fu_105_p2;\nwire   [0:0] icmp_ln1019_3_fu_111_p2;\nwire   [0:0] icmp_ln1019_4_fu_117_p2;\nwire   [0:0] icmp_ln1019_7_fu_135_p2;\nwire   [0:0] icmp_ln1019_8_fu_141_p2;\nwire   [0:0] icmp_ln1019_9_fu_147_p2;\nwire   [0:0] and_ln1497_fu_159_p2;\nwire   [0:0] and_ln1497_1_fu_165_p2;\nwire   [0:0] and_ln1497_3_fu_177_p2;\nwire   [0:0] and_ln1497_4_fu_183_p2;\nwire   [0:0] or_ln1498_1_fu_214_p2;\nwire   [0:0] and_ln1497_2_fu_171_p2;\nwire   [0:0] or_ln1498_2_fu_220_p2;\nwire   [0:0] or_ln1498_fu_208_p2;\nwire   [0:0] icmp_ln1019_5_fu_123_p2;\nwire   [0:0] icmp_ln1019_6_fu_129_p2;\nwire   [0:0] or_ln1498_4_fu_232_p2;\nwire   [0:0] and_ln1497_6_fu_196_p2;\nwire   [0:0] and_ln1497_7_fu_202_p2;\nwire   [0:0] or_ln1498_5_fu_244_p2;\nwire   [0:0] or_ln1498_6_fu_250_p2;\nwire   [0:0] and_ln1498_fu_238_p2;\nwire   [0:0] or_ln1498_7_fu_256_p2;\nwire   [0:0] or_ln1498_3_fu_226_p2;\nwire   [0:0] ret_V_fu_262_p2;\nwire   [0:0] and_ln1497_8_fu_273_p2;\n\nassign and_ln1497_1_fu_165_p2 = (in_r & icmp_ln1019_1_fu_99_p2);\n\nassign and_ln1497_2_fu_171_p2 = (xor_ln901_fu_153_p2 & icmp_ln1019_2_fu_105_p2);\n\nassign and_ln1497_3_fu_177_p2 = (in_r & icmp_ln1019_3_fu_111_p2);\n\nassign and_ln1497_4_fu_183_p2 = (xor_ln901_fu_153_p2 & icmp_ln1019_4_fu_117_p2);\n\nassign and_ln1497_5_fu_189_p2 = (in_r & icmp_ln1019_7_fu_135_p2);\n\nassign and_ln1497_6_fu_196_p2 = (xor_ln901_fu_153_p2 & icmp_ln1019_8_fu_141_p2);\n\nassign and_ln1497_7_fu_202_p2 = (in_r & icmp_ln1019_9_fu_147_p2);\n\nassign and_ln1497_8_fu_273_p2 = (xor_ln901_fu_153_p2 & icmp_ln1019_7_fu_135_p2);\n\nassign and_ln1497_fu_159_p2 = (xor_ln901_fu_153_p2 & icmp_ln1019_fu_93_p2);\n\nassign and_ln1498_fu_238_p2 = (xor_ln901_fu_153_p2 & or_ln1498_4_fu_232_p2);\n\nassign or_ln1498_1_fu_214_p2 = (and_ln1497_4_fu_183_p2 | and_ln1497_3_fu_177_p2);\n\nassign or_ln1498_2_fu_220_p2 = (or_ln1498_1_fu_214_p2 | and_ln1497_2_fu_171_p2);\n\nassign or_ln1498_3_fu_226_p2 = (or_ln1498_fu_208_p2 | or_ln1498_2_fu_220_p2);\n\nassign or_ln1498_4_fu_232_p2 = (icmp_ln1019_6_fu_129_p2 | icmp_ln1019_5_fu_123_p2);\n\nassign or_ln1498_5_fu_244_p2 = (and_ln1497_7_fu_202_p2 | and_ln1497_6_fu_196_p2);\n\nassign or_ln1498_6_fu_250_p2 = (or_ln1498_5_fu_244_p2 | and_ln1497_5_fu_189_p2);\n\nassign or_ln1498_7_fu_256_p2 = (or_ln1498_6_fu_250_p2 | and_ln1498_fu_238_p2);\n\nassign or_ln1498_fu_208_p2 = (and_ln1497_fu_159_p2 | and_ln1497_1_fu_165_p2);\n\nassign ret_V_fu_262_p2 = (or_ln1498_7_fu_256_p2 | or_ln1498_3_fu_226_p2);\n\nassign xor_ln901_fu_153_p2 = (in_r ^ 1'd1);\n\nassign icmp_ln1019_1_fu_99_p2 = ((state == 10'd2) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_2_fu_105_p2 = ((state == 10'd4) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_3_fu_111_p2 = ((state == 10'd8) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_4_fu_117_p2 = ((state == 10'd16) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_5_fu_123_p2 = ((state == 10'd32) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_6_fu_129_p2 = ((state == 10'd64) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_7_fu_135_p2 = ((state == 10'd128) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_8_fu_141_p2 = ((state == 10'd256) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_9_fu_147_p2 = ((state == 10'd512) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_fu_93_p2 = ((state == 10'd1) ? 1'b1 : 1'b0);\n\nassign next_state = ret_V_fu_262_p2;\n\nassign out1 = (or_ln1498_5_fu_244_p2 | and_ln1497_8_fu_273_p2);\n\nassign out2 = and_ln1497_5_fu_189_p2;\n\nendmodule //fsm_onehot", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in,\n\toutput logic [9:0] state,\n\tinput tb_match,\n\tinput [9:0] next_state_ref,\n\tinput [9:0] next_state_dut,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tint errored1 = 0;\n\tint errored2 = 0;\n\tint onehot_error = 0;\n\treg [9:0] state_error = 10'h0;\n\t\n\tinitial begin\n\t\trepeat(2) @(posedge clk);\n\t\tforever @(posedge clk, negedge clk)\n\t\t\tstate_error <= state_error | (next_state_ref^next_state_dut);\n\tend\n\t\t\n\tinitial begin\n\t\tstate <= 0;\n\t\t\n\t\t@(negedge clk) wavedrom_start();\n\t\tfor (int i=0;i<10;i++) begin\n\t\t\t@(negedge clk, posedge clk);\n\t\t\tstate <= 1<< i;\n\t\t\tin <= 0;\n\t\tend\n\t\tfor (int i=0;i<10;i++) begin\n\t\t\t@(negedge clk, posedge clk);\n\t\t\tstate <= 1<< i;\n\t\t\tin <= 1;\n\t\tend\t\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\t// Test the one-hot cases first.\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\tstate <= 1<< ($unsigned($random) % 10);\n\t\t\tin <= $random;\n\t\t\tif (!tb_match) onehot_error++;\n\t\tend\n\t\t\n\t\t// Two-hot.\n\t\terrored1 = 0;\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tstate <= (1<< ($unsigned($random) % 10)) | (1<< ($unsigned($random) % 10));\n\t\t\tin <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored1++;\n\t\tend\n\t\t\n\t\tif (!onehot_error && errored1) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with two-hot inputs.\");\n\t\t\n\t\t// Random.\n\t\terrored2 = 0;\n\t\trepeat(800) @(posedge clk, negedge clk) begin\n\t\t\tstate <= $random;\n\t\t\tin <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored2++;\n\t\tend\n\t\tif (!onehot_error && errored2) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with random inputs.\");\n\n\t\tif (!onehot_error && (errored1 || errored2))\n\t\t\t$display(\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\t\t\n\t\tfor (int i=0;i<$bits(state_error);i++)\n\t\t\t$display(\"Hint: next_state[%0d] is %s.\", i, (state_error[i] === 1'b0) ? \"correct\": \"incorrect\");\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_next_state;\n\t\tint errortime_next_state;\n\t\tint errors_out1;\n\t\tint errortime_out1;\n\t\tint errors_out2;\n\t\tint errortime_out2;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic [9:0] state;\n\tlogic [9:0] next_state_ref;\n\tlogic [9:0] next_state_dut;\n\tlogic out1_ref;\n\tlogic out1_dut;\n\tlogic out2_ref;\n\tlogic out2_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.state );\n\treference_module good1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_ref),\n\t\t.out1(out1_ref),\n\t\t.out2(out2_ref) );\n\t\t\n\tfsm_onehot top_module1 (\n\t\t.in_r(in),\n\t\t.state,\n\t\t.next_state(next_state_dut),\n\t\t.out1(out1_dut),\n\t\t.out2(out2_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_next_state) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"next_state\", stats1.errors_next_state, stats1.errortime_next_state);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"next_state\");\n\t\tif (stats1.errors_out1) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out1\", stats1.errors_out1, stats1.errortime_out1);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out1\");\n\t\tif (stats1.errors_out2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out2\", stats1.errors_out2, stats1.errortime_out2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out2\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { next_state_ref, out1_ref, out2_ref } === ( { next_state_ref, out1_ref, out2_ref } ^ { next_state_dut, out1_dut, out2_dut } ^ { next_state_ref, out1_ref, out2_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (next_state_ref !== ( next_state_ref ^ next_state_dut ^ next_state_ref ))\n\t\tbegin if (stats1.errors_next_state == 0) stats1.errortime_next_state = $time;\n\t\t\tstats1.errors_next_state = stats1.errors_next_state+1'b1; end\n\t\tif (out1_ref !== ( out1_ref ^ out1_dut ^ out1_ref ))\n\t\tbegin if (stats1.errors_out1 == 0) stats1.errortime_out1 = $time;\n\t\t\tstats1.errors_out1 = stats1.errors_out1+1'b1; end\n\t\tif (out2_ref !== ( out2_ref ^ out2_dut ^ out2_ref ))\n\t\tbegin if (stats1.errors_out2 == 0) stats1.errortime_out2 = $time;\n\t\t\tstats1.errors_out2 = stats1.errors_out2+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vector0", "prompt": "module vector0 (\n        vec,\n        outv,\n        o2,\n        o1,\n        o0\n);\n\n\ninput  [2:0] vec;\noutput  [2:0] outv;\noutput  [0:0] o2;\noutput  [0:0] o1;\noutput  [0:0] o0;", "canonical_solution": "assign o0 = vec[0:0];\n\nassign o1 = vec[32'd1];\n\nassign o2 = vec[32'd2];\n\nassign outv = vec;\n\nendmodule //vector0", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\t\n\tassign outv = vec;\n\tassign {o2, o1, o0} = vec;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [2:0] vec,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\tvec <= 3'b0;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\trepeat(10) @(posedge clk)\n\t\t\tvec <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_outv;\n\t\tint errortime_outv;\n\t\tint errors_o2;\n\t\tint errortime_o2;\n\t\tint errors_o1;\n\t\tint errortime_o1;\n\t\tint errors_o0;\n\t\tint errortime_o0;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] vec;\n\tlogic [2:0] outv_ref;\n\tlogic [2:0] outv_dut;\n\tlogic o2_ref;\n\tlogic o2_dut;\n\tlogic o1_ref;\n\tlogic o1_dut;\n\tlogic o0_ref;\n\tlogic o0_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.vec );\n\treference_module good1 (\n\t\t.vec,\n\t\t.outv(outv_ref),\n\t\t.o2(o2_ref),\n\t\t.o1(o1_ref),\n\t\t.o0(o0_ref) );\n\t\t\n\tvector0 top_module1 (\n\t\t.vec,\n\t\t.outv(outv_dut),\n\t\t.o2(o2_dut),\n\t\t.o1(o1_dut),\n\t\t.o0(o0_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_outv) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"outv\", stats1.errors_outv, stats1.errortime_outv);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"outv\");\n\t\tif (stats1.errors_o2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"o2\", stats1.errors_o2, stats1.errortime_o2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"o2\");\n\t\tif (stats1.errors_o1) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"o1\", stats1.errors_o1, stats1.errortime_o1);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"o1\");\n\t\tif (stats1.errors_o0) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"o0\", stats1.errors_o0, stats1.errortime_o0);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"o0\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { outv_ref, o2_ref, o1_ref, o0_ref } === ( { outv_ref, o2_ref, o1_ref, o0_ref } ^ { outv_dut, o2_dut, o1_dut, o0_dut } ^ { outv_ref, o2_ref, o1_ref, o0_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (outv_ref !== ( outv_ref ^ outv_dut ^ outv_ref ))\n\t\tbegin if (stats1.errors_outv == 0) stats1.errortime_outv = $time;\n\t\t\tstats1.errors_outv = stats1.errors_outv+1'b1; end\n\t\tif (o2_ref !== ( o2_ref ^ o2_dut ^ o2_ref ))\n\t\tbegin if (stats1.errors_o2 == 0) stats1.errortime_o2 = $time;\n\t\t\tstats1.errors_o2 = stats1.errors_o2+1'b1; end\n\t\tif (o1_ref !== ( o1_ref ^ o1_dut ^ o1_ref ))\n\t\tbegin if (stats1.errors_o1 == 0) stats1.errortime_o1 = $time;\n\t\t\tstats1.errors_o1 = stats1.errors_o1+1'b1; end\n\t\tif (o0_ref !== ( o0_ref ^ o0_dut ^ o0_ref ))\n\t\tbegin if (stats1.errors_o0 == 0) stats1.errortime_o0 = $time;\n\t\t\tstats1.errors_o0 = stats1.errors_o0+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vector4", "prompt": "module vector4 (\n        in_r,\n        out_r\n);\n\n\ninput  [7:0] in_r;\noutput  [31:0] out_r;", "canonical_solution": "wire   [0:0] tmp_fu_51_p3;\nwire   [16:0] select_ln5_fu_59_p3;\nwire   [24:0] ret_V_fu_67_p3;\n\nassign ret_V_fu_67_p3 = {{select_ln5_fu_59_p3}, {in_r}};\n\nassign select_ln5_fu_59_p3 = ((tmp_fu_51_p3[0:0] == 1'b1) ? 17'd65536 : 17'd0);\n\nassign tmp_fu_51_p3 = in_r[32'd7];\n\nassign out_r = $signed(ret_V_fu_67_p3);\n\nendmodule //vector4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = { {24{in[7]}}, in };\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic [31:0] out_ref;\n\tlogic [31:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tvector4 top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q6c", "prompt": "module m2014_q6c (\n        y,\n        w,\n        Y2,\n        Y4\n);\n\n\ninput  [5:0] y;\ninput  [0:0] w;\noutput  [0:0] Y2;\noutput  [0:0] Y4;", "canonical_solution": "wire   [0:0] icmp_ln8_fu_62_p2;\nwire   [0:0] icmp_ln8_1_fu_68_p2;\nwire   [0:0] icmp_ln8_2_fu_74_p2;\nwire   [0:0] icmp_ln8_3_fu_80_p2;\nwire   [0:0] or_ln8_1_fu_92_p2;\nwire   [0:0] or_ln8_fu_86_p2;\nwire   [0:0] icmp_ln9_fu_105_p2;\nwire   [0:0] or_ln9_fu_111_p2;\n\nassign or_ln8_1_fu_92_p2 = (icmp_ln8_3_fu_80_p2 | icmp_ln8_2_fu_74_p2);\n\nassign or_ln8_fu_86_p2 = (icmp_ln8_fu_62_p2 | icmp_ln8_1_fu_68_p2);\n\nassign or_ln9_fu_111_p2 = (icmp_ln9_fu_105_p2 | icmp_ln8_3_fu_80_p2);\n\nassign Y2 = (or_ln8_fu_86_p2 | or_ln8_1_fu_92_p2);\n\nassign Y4 = (or_ln9_fu_111_p2 | icmp_ln8_1_fu_68_p2);\n\nassign icmp_ln8_1_fu_68_p2 = ((y == 8'd2) ? 1'b1 : 1'b0);\n\nassign icmp_ln8_2_fu_74_p2 = ((y == 8'd8) ? 1'b1 : 1'b0);\n\nassign icmp_ln8_3_fu_80_p2 = ((y == 8'd32) ? 1'b1 : 1'b0);\n\nassign icmp_ln8_fu_62_p2 = ((y == 8'd1) ? 1'b1 : 1'b0);\n\nassign icmp_ln9_fu_105_p2 = ((y == 8'd16) ? 1'b1 : 1'b0);\n\nendmodule //m2014_q6c", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[0]&~w;\n\tassign Y4 = (y[1]|y[2]|y[4]|y[5]) & w;\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic[5:0] y,\n\toutput logic w,\n\tinput tb_match\n);\n\n\tint errored1 = 0;\n\tint onehot_error = 0;\n\tint temp;\n\t\n\tinitial begin\n\t\t// Test the one-hot cases first.\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\ty <= 1<< ($unsigned($random) % 6);\n\t\t\tw <= $random;\n\t\t\tif (!tb_match) onehot_error++;\n\t\tend\n\t\t\t\n\t\t\t\n\t\t// Random.\n\t\terrored1 = 0;\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tdo \n\t\t\t\ttemp = $random;\n\t\t\twhile ( !{temp[5:4],temp[2:1]} == !{temp[3],temp[0]} );\t\n\t\t\t// Make y[4,1] and y[6,5,3,2] mutually exclusive, so we can accept Y4=(~y[1] & ~y[4]) &w as a valid answer too.\n\n\t\t\ty[5:0] <= temp[5:0];\n\t\t\tw <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored1++;\n\t\tend\n\t\tif (!onehot_error && errored1) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with semi-random inputs.\");\n\n\t\tif (!onehot_error && errored1)\n\t\t\t$display(\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Y2;\n\t\tint errortime_Y2;\n\t\tint errors_Y4;\n\t\tint errortime_Y4;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [5:0] y;\n\tlogic w;\n\tlogic Y2_ref;\n\tlogic Y2_dut;\n\tlogic Y4_ref;\n\tlogic Y4_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.y,\n\t\t.w );\n\treference_module good1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_ref),\n\t\t.Y4(Y4_ref) );\n\t\t\n\t m2014_q6c top_module1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_dut),\n\t\t.Y4(Y4_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Y2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y2\", stats1.errors_Y2, stats1.errortime_Y2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y2\");\n\t\tif (stats1.errors_Y4) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y4\", stats1.errors_Y4, stats1.errortime_Y4);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y4\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Y2_ref, Y4_ref } === ( { Y2_ref, Y4_ref } ^ { Y2_dut, Y4_dut } ^ { Y2_ref, Y4_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Y2_ref !== ( Y2_ref ^ Y2_dut ^ Y2_ref ))\n\t\tbegin if (stats1.errors_Y2 == 0) stats1.errortime_Y2 = $time;\n\t\t\tstats1.errors_Y2 = stats1.errors_Y2+1'b1; end\n\t\tif (Y4_ref !== ( Y4_ref ^ Y4_dut ^ Y4_ref ))\n\t\tbegin if (stats1.errors_Y4 == 0) stats1.errortime_Y4 = $time;\n\t\t\tstats1.errors_Y4 = stats1.errors_Y4+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "step_one", "prompt": "module step_one (\n        one\n);\n\n\noutput  [0:0] one;", "canonical_solution": "assign one = 1'd1;\n\nendmodule //step_one", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\toutput one);\n\t\n\tassign one = 1'b1;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start(\"Output should be 1\");\n\t\trepeat(20) @(posedge clk, negedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_one;\n\t\tint errortime_one;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic one_ref;\n\tlogic one_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.*  );\n\treference_module good1 (\n\t\t.one(one_ref) );\n\t\t\n\tstep_one top_module1 (\n\t\t.one(one_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_one) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"one\", stats1.errors_one, stats1.errortime_one);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"one\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { one_ref } === ( { one_ref } ^ { one_dut } ^ { one_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (one_ref !== ( one_ref ^ one_dut ^ one_ref ))\n\t\tbegin if (stats1.errors_one == 0) stats1.errortime_one = $time;\n\t\t\tstats1.errors_one = stats1.errors_one+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "wire4", "prompt": "module wire4 (\n        a,\n        b,\n        c,\n        w,\n        x,\n        y,\n        z\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\noutput  [0:0] w;\noutput  [0:0] x;\noutput  [0:0] y;\noutput  [0:0] z;", "canonical_solution": "assign w = a;\n\nassign x = b;\n\nassign y = b;\n\nassign z = c;\n\nendmodule //wire4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\t\n\tassign {w,x,y,z} = {a,b,b,c};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a, b, c,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\talways @(posedge clk, negedge clk)\n\t\t{a,b,c} <= $random;\n\t\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start();\n\t\t\trepeat(8) @(posedge clk);\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_w;\n\t\tint errortime_w;\n\t\tint errors_x;\n\t\tint errortime_x;\n\t\tint errors_y;\n\t\tint errortime_y;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic w_ref;\n\tlogic w_dut;\n\tlogic x_ref;\n\tlogic x_dut;\n\tlogic y_ref;\n\tlogic y_dut;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.w(w_ref),\n\t\t.x(x_ref),\n\t\t.y(y_ref),\n\t\t.z(z_ref) );\n\t\t\n\twire4 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.w(w_dut),\n\t\t.x(x_dut),\n\t\t.y(y_dut),\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_w) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"w\", stats1.errors_w, stats1.errortime_w);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"w\");\n\t\tif (stats1.errors_x) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"x\", stats1.errors_x, stats1.errortime_x);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"x\");\n\t\tif (stats1.errors_y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"y\", stats1.errors_y, stats1.errortime_y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"y\");\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { w_ref, x_ref, y_ref, z_ref } === ( { w_ref, x_ref, y_ref, z_ref } ^ { w_dut, x_dut, y_dut, z_dut } ^ { w_ref, x_ref, y_ref, z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (w_ref !== ( w_ref ^ w_dut ^ w_ref ))\n\t\tbegin if (stats1.errors_w == 0) stats1.errortime_w = $time;\n\t\t\tstats1.errors_w = stats1.errors_w+1'b1; end\n\t\tif (x_ref !== ( x_ref ^ x_dut ^ x_ref ))\n\t\tbegin if (stats1.errors_x == 0) stats1.errortime_x = $time;\n\t\t\tstats1.errors_x = stats1.errors_x+1'b1; end\n\t\tif (y_ref !== ( y_ref ^ y_dut ^ y_ref ))\n\t\tbegin if (stats1.errors_y == 0) stats1.errortime_y = $time;\n\t\t\tstats1.errors_y = stats1.errors_y+1'b1; end\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "gatesv", "prompt": "module gatesv (\n        in_r,\n        out_both,\n        out_any,\n        out_different\n);\n\n\ninput  [3:0] in_r;\noutput  [2:0] out_both;\noutput  [3:0] out_any;\noutput  [3:0] out_different;", "canonical_solution": "wire   [3:0] p_Result_s_fu_75_p1;\nwire   [0:0] icmp_ln1019_fu_79_p2;\nwire   [1:0] trunc_ln628_1_fu_94_p1;\nwire   [0:0] icmp_ln1023_fu_98_p2;\nwire   [2:0] p_Resul,t_1_fu_115_p4;\nreg   [2:0] p_Result_2_fu_129_p4;\nwire   [3:0] r_V_fu_109_p2;\nwire   [3:0] zext_ln628_fu_125_p1;\nwire   [0:0] icmp_ln530_fu_139_p2;\nwire   [0:0] icmp_ln1023_1_fu_145_p2;\nwire   [0:0] and_ln1023_fu_151_p2;\n\nassign and_ln1023_fu_151_p2 = (icmp_ln530_fu_139_p2 & icmp_ln1023_1_fu_145_p2);\n\nassign p_Result_1_fu_115_p4 = {{in_r[3:1]}};\n\ninteger ap_tvar_int_0;\n\nalways @ (in_r) begin\n    for (ap_tvar_int_0 = 3 - 1; ap_tvar_int_0 >= 0; ap_tvar_int_0 = ap_tvar_int_0 - 1) begin\n        if (ap_tvar_int_0 > 2 - 0) begin\n            p_Result_2_fu_129_p4[ap_tvar_int_0] = 1'b0;\n        end else begin\n            p_Result_2_fu_129_p4[ap_tvar_int_0] = in_r[2 - ap_tvar_int_0];\n        end\n    end\nend\n\nassign p_Result_s_fu_75_p1 = in_r[2:0];\n\nassign r_V_fu_109_p2 = in_r << 4'd1;\n\nassign trunc_ln628_1_fu_94_p1 = in_r[1:0];\n\nassign zext_ln628_fu_125_p1 = p_Result_1_fu_115_p4;\n\nassign icmp_ln1019_fu_79_p2 = ((p_Result_s_fu_75_p1 == 3'd7) ? 1'b1 : 1'b0);\n\nassign icmp_ln1023_1_fu_145_p2 = ((r_V_fu_109_p2 != zext_ln628_fu_125_p1) ? 1'b1 : 1'b0);\n\nassign icmp_ln1023_fu_98_p2 = ((trunc_ln628_1_fu_94_p1 != 2'd0) ? 1'b1 : 1'b0);\n\nassign icmp_ln530_fu_139_p2 = ((p_Result_2_fu_129_p4 != p_Result_1_fu_115_p4) ? 1'b1 : 1'b0);\n\nassign out_any = icmp_ln1023_fu_98_p2;\n\nassign out_both = ((icmp_ln1019_fu_79_p2[0:0] == 1'b1) ? 3'd7 : 3'd0);\n\nassign out_different = ((and_ln1023_fu_151_p2[0:0] == 1'b1) ? 3'd7 : 3'd0);\n\nendmodule //gatesv", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:0] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = {in[2:0] | in[3:1], in[0]};\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput logic [3:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tin <= 4'h3;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\t\t@(posedge clk) in <= 3;\n\t\t\t@(posedge clk) in <= 6;\n\t\t\t@(posedge clk) in <= 12;\n\t\t\t@(posedge clk) in <= 9;\n\t\t\t@(posedge clk) in <= 5;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\tin <= $random;\n\t\trepeat(100) begin\n\t\t\t@(negedge clk) in <= $random;\n\t\t\t@(posedge clk) in <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_both;\n\t\tint errortime_out_both;\n\t\tint errors_out_any;\n\t\tint errortime_out_any;\n\t\tint errors_out_different;\n\t\tint errortime_out_different;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] in;\n\tlogic [2:0] out_both_ref;\n\tlogic [2:0] out_both_dut;\n\tlogic [3:0] out_any_ref;\n\tlogic [3:0] out_any_dut;\n\tlogic [3:0] out_different_ref;\n\tlogic [3:0] out_different_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_both(out_both_ref),\n\t\t.out_any(out_any_ref),\n\t\t.out_different(out_different_ref) );\n\t\t\n\tgatesv top_module1 (\n\t\t.in_r(in),\n\t\t.out_both(out_both_dut),\n\t\t.out_any(out_any_dut),\n\t\t.out_different(out_different_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_both) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_both\", stats1.errors_out_both, stats1.errortime_out_both);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_both\");\n\t\tif (stats1.errors_out_any) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_any\", stats1.errors_out_any, stats1.errortime_out_any);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_any\");\n\t\tif (stats1.errors_out_different) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_different\", stats1.errors_out_different, stats1.errortime_out_different);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_different\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_both_ref, out_any_ref, out_different_ref } === ( { out_both_ref, out_any_ref, out_different_ref } ^ { out_both_dut, out_any_dut, out_different_dut } ^ { out_both_ref, out_any_ref, out_different_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_both_ref !== ( out_both_ref ^ out_both_dut ^ out_both_ref ))\n\t\tbegin if (stats1.errors_out_both == 0) stats1.errortime_out_both = $time;\n\t\t\tstats1.errors_out_both = stats1.errors_out_both+1'b1; end\n\t\tif (out_any_ref !== ( out_any_ref ^ out_any_dut ^ out_any_ref ))\n\t\tbegin if (stats1.errors_out_any == 0) stats1.errortime_out_any = $time;\n\t\t\tstats1.errors_out_any = stats1.errors_out_any+1'b1; end\n\t\tif (out_different_ref !== ( out_different_ref ^ out_different_dut ^ out_different_ref ))\n\t\tbegin if (stats1.errors_out_different == 0) stats1.errortime_out_different = $time;\n\t\t\tstats1.errors_out_different = stats1.errors_out_different+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mt2015_eq2", "prompt": "module mt2015_eq2 (\n        A,\n        B,\n        z\n);\n\n\ninput  [1:0] A;\ninput  [1:0] B;\noutput  [0:0] z;", "canonical_solution": "assign z = ((A == B) ? 1'b1 : 1'b0);\n\nendmodule //mt2015_eq2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\n/*\n\tMidterm 2015 Question 1k. 2-bit equality comparator.\n*/\nmodule reference_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]==B[1:0];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [1:0] A,\n\toutput logic [1:0] B\n);\n\n\talways @(posedge clk, negedge clk)\n\t\t{A, B} <= $random % 16;\n\t\n\tinitial begin\n\t\trepeat(1000) @(negedge clk);\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [1:0] A;\n\tlogic [1:0] B;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.A,\n\t\t.B );\n\treference_module good1 (\n\t\t.A,\n\t\t.B,\n\t\t.z(z_ref) );\n\t\t\n\tmt2015_eq2 top_module1 (\n\t\t.A,\n\t\t.B,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "truthtable1", "prompt": "module truthtable1 (\n        x3,\n        x2,\n        x1,\n        f\n);\n\n\ninput  [0:0] x3;\ninput  [0:0] x2;\ninput  [0:0] x1;\noutput  [0:0] f;", "canonical_solution": "wire   [0:0] rhs_V_fu_59_p2;\nwire   [0:0] and_ln1497_1_fu_65_p2;\nwire   [0:0] and_ln1497_3_fu_83_p2;\nwire   [0:0] lhs_V_fu_77_p2;\nwire   [0:0] or_ln5_fu_95_p2;\nwire   [0:0] xor_ln5_fu_101_p2;\nwire   [0:0] and_ln1497_5_fu_119_p2;\nwire   [0:0] rhs_V_1_fu_113_p2;\nwire   [0:0] ret_V_fu_71_p2;\nwire   [0:0] ret_V_1_fu_89_p2;\nwire   [0:0] and_ln1497_fu_107_p2;\nwire   [0:0] ret_V_2_fu_125_p2;\nwire   [0:0] or_ln1497_1_fu_137_p2;\nwire   [0:0] or_ln1497_fu_131_p2;\n\nassign and_ln1497_1_fu_65_p2 = (x2 & rhs_V_fu_59_p2);\n\nassign and_ln1497_3_fu_83_p2 = (x2 & x1);\n\nassign and_ln1497_5_fu_119_p2 = (x3 & x1);\n\nassign and_ln1497_fu_107_p2 = (xor_ln5_fu_101_p2 & x1);\n\nassign lhs_V_fu_77_p2 = (x3 ^ 1'd1);\n\nassign or_ln1497_1_fu_137_p2 = (ret_V_2_fu_125_p2 | and_ln1497_fu_107_p2);\n\nassign or_ln1497_fu_131_p2 = (ret_V_fu_71_p2 | ret_V_1_fu_89_p2);\n\nassign or_ln5_fu_95_p2 = (x3 | x2);\n\nassign ret_V_1_fu_89_p2 = (lhs_V_fu_77_p2 & and_ln1497_3_fu_83_p2);\n\nassign ret_V_2_fu_125_p2 = (rhs_V_1_fu_113_p2 & and_ln1497_5_fu_119_p2);\n\nassign ret_V_fu_71_p2 = (x3 & and_ln1497_1_fu_65_p2);\n\nassign rhs_V_1_fu_113_p2 = (x2 ^ 1'd1);\n\nassign rhs_V_fu_59_p2 = (x1 ^ 1'd1);\n\nassign xor_ln5_fu_101_p2 = (or_ln5_fu_95_p2 ^ 1'd1);\n\nassign f = (or_ln1497_fu_131_p2 | or_ln1497_1_fu_137_p2);\n\nendmodule //truthtable1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg x3, x2, x1,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\t{x3, x2, x1} <= 3'h7;\n\t\t@(negedge clk) wavedrom_start(\"All 8 input combinations\");\n\t\trepeat(8) @(posedge clk) {x3, x2, x1} <= {x3, x2, x1} + 1'b1;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(40) @(posedge clk, negedge clk);\n\t\t{x3, x2, x1} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_f;\n\t\tint errortime_f;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x3;\n\tlogic x2;\n\tlogic x1;\n\tlogic f_ref;\n\tlogic f_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x3,\n\t\t.x2,\n\t\t.x1 );\n\treference_module good1 (\n\t\t.x3,\n\t\t.x2,\n\t\t.x1,\n\t\t.f(f_ref) );\n\t\t\n\ttruthtable1 top_module1 (\n\t\t.x3,\n\t\t.x2,\n\t\t.x1,\n\t\t.f(f_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_f) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"f\", stats1.errors_f, stats1.errortime_f);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"f\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { f_ref } === ( { f_ref } ^ { f_dut } ^ { f_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (f_ref !== ( f_ref ^ f_dut ^ f_ref ))\n\t\tbegin if (stats1.errors_f == 0) stats1.errortime_f = $time;\n\t\t\tstats1.errors_f = stats1.errors_f+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "circuit5", "prompt": "module circuit5 (\n        a,\n        b,\n        c,\n        d,\n        e,\n        q\n);\n\n\ninput  [3:0] a;\ninput  [3:0] b;\ninput  [3:0] c;\ninput  [3:0] d;\ninput  [3:0] e;\noutput  [3:0] q;", "canonical_solution": "reg[3:0] q;\n\nwire   [3:0] e_read_read_fu_48_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((e_read_read_fu_48_p2 == 4'd0)) begin\n        q = a;\n    end else if ((e_read_read_fu_48_p2 == 4'd1)) begin\n        q = b;\n    end else if ((e_read_read_fu_48_p2 == 4'd2)) begin\n        q = c;\n    end else if ((e_read_read_fu_48_p2 == 4'd3)) begin\n        q = d;\n    end else if (((e_read_read_fu_48_p2 == 4'd4) | (~(e_read_read_fu_48_p2 == 4'd0) & ~(e_read_read_fu_48_p2 == 4'd1) & ~(e_read_read_fu_48_p2 == 4'd2) & ~(e_read_read_fu_48_p2 == 4'd3) & ~(e_read_read_fu_48_p2 == 4'd4)))) begin\n        q = 4'd15;\n    end else begin\n        q = 'bx;\n    end\nend\n\nassign e_read_read_fu_48_p2 = e;\n\nendmodule //circuit5", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [3:0] a,b,c,d,e,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b,c,d,e} <= {20'hab0de};\n\t\t\trepeat(18) @(posedge clk, negedge clk) c <= c + 1;\n\t\twavedrom_stop();\n\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b,c,d,e} <= {20'h12034};\n\t\t\trepeat(8) @(posedge clk, negedge clk) c <= c + 1;\n\t\t\t@(posedge clk) {a,b,c,d,e} <= {20'h56078};\n\t\t\trepeat(8) @(posedge clk, negedge clk) c <= c + 1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d,e} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] a;\n\tlogic [3:0] b;\n\tlogic [3:0] c;\n\tlogic [3:0] d;\n\tlogic [3:0] e;\n\tlogic [3:0] q_ref;\n\tlogic [3:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit5 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "gates4", "prompt": "module gates4 (\n        in_r,\n        out_and,\n        out_or,\n        out_xor\n);\n\n\ninput  [3:0] in_r;\noutput  [0:0] out_and;\noutput  [0:0] out_or;\noutput  [0:0] out_xor;", "canonical_solution": "wire   [0:0] tmp_fu_87_p3;\nwire   [0:0] trunc_ln9_fu_83_p1;\nwire   [0:0] tmp_1_fu_95_p3;\nwire   [0:0] tmp_2_fu_103_p3;\nwire   [0:0] xor_ln301_2_fu_117_p2;\nwire   [0:0] xor_ln301_1_fu_111_p2;\n\nassign out_and = ((in_r == 4'd15) ? 1'b1 : 1'b0);\n\nassign out_or = ((in_r != 4'd0) ? 1'b1 : 1'b0);\n\nassign out_xor = (xor_ln301_2_fu_117_p2 ^ xor_ln301_1_fu_111_p2);\n\nassign tmp_1_fu_95_p3 = in_r[32'd2];\n\nassign tmp_2_fu_103_p3 = in_r[32'd3];\n\nassign tmp_fu_87_p3 = in_r[32'd1];\n\nassign trunc_ln9_fu_83_p1 = in_r[0:0];\n\nassign xor_ln301_1_fu_111_p2 = (trunc_ln9_fu_83_p1 ^ tmp_fu_87_p3);\n\nassign xor_ln301_2_fu_117_p2 = (tmp_2_fu_103_p3 ^ tmp_1_fu_95_p3);\n\nendmodule //gates4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [3:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(negedge clk) wavedrom_start(\"All combinations\");\n\t\t\t@(posedge clk);\n\t\t\trepeat(15) @(posedge clk) in <= in + 1;\n\t\t@(negedge clk) wavedrom_stop();\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_and;\n\t\tint errortime_out_and;\n\t\tint errors_out_or;\n\t\tint errortime_out_or;\n\t\tint errors_out_xor;\n\t\tint errortime_out_xor;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] in;\n\tlogic out_and_ref;\n\tlogic out_and_dut;\n\tlogic out_or_ref;\n\tlogic out_or_dut;\n\tlogic out_xor_ref;\n\tlogic out_xor_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_and(out_and_ref),\n\t\t.out_or(out_or_ref),\n\t\t.out_xor(out_xor_ref) );\n\t\t\n\tgates4 top_module1 (\n\t\t.in_r(in),\n\t\t.out_and(out_and_dut),\n\t\t.out_or(out_or_dut),\n\t\t.out_xor(out_xor_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_and) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_and\", stats1.errors_out_and, stats1.errortime_out_and);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_and\");\n\t\tif (stats1.errors_out_or) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or\", stats1.errors_out_or, stats1.errortime_out_or);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or\");\n\t\tif (stats1.errors_out_xor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_xor\", stats1.errors_out_xor, stats1.errortime_out_xor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_xor\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_and_ref, out_or_ref, out_xor_ref } === ( { out_and_ref, out_or_ref, out_xor_ref } ^ { out_and_dut, out_or_dut, out_xor_dut } ^ { out_and_ref, out_or_ref, out_xor_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_and_ref !== ( out_and_ref ^ out_and_dut ^ out_and_ref ))\n\t\tbegin if (stats1.errors_out_and == 0) stats1.errortime_out_and = $time;\n\t\t\tstats1.errors_out_and = stats1.errors_out_and+1'b1; end\n\t\tif (out_or_ref !== ( out_or_ref ^ out_or_dut ^ out_or_ref ))\n\t\tbegin if (stats1.errors_out_or == 0) stats1.errortime_out_or = $time;\n\t\t\tstats1.errors_out_or = stats1.errors_out_or+1'b1; end\n\t\tif (out_xor_ref !== ( out_xor_ref ^ out_xor_dut ^ out_xor_ref ))\n\t\tbegin if (stats1.errors_out_xor == 0) stats1.errortime_out_xor = $time;\n\t\t\tstats1.errors_out_xor = stats1.errors_out_xor+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "always_nolatches", "prompt": "module always_nolatches (\n        scancode,\n        left_r,\n        down,\n        right_r,\n        up\n);\n\n\ninput  [15:0] scancode;\noutput  [2:0] left_r;\noutput  [0:0] down;\noutput  [0:0] right_r;\noutput  [0:0] up;", "canonical_solution": "reg[2:0] left_r;\nreg[0:0] down;\nreg[0:0] right_r;\nreg[0:0] up;\n\nwire   [15:0] scancode_read_read_fu_52_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((scancode_read_read_fu_52_p2 == 16'd57458)) begin\n        down = 1'd1;\n    end else if (((scancode_read_read_fu_52_p2 == 16'd57451) | (scancode_read_read_fu_52_p2 == 16'd57460) | (scancode_read_read_fu_52_p2 == 16'd57461) | (~(scancode_read_read_fu_52_p2 == 16'd57451) & ~(scancode_read_read_fu_52_p2 == 16'd57458) & ~(scancode_read_read_fu_52_p2 == 16'd57460) & ~(scancode_read_read_fu_52_p2 == 16'd57461)))) begin\n        down = 1'd0;\n    end else begin\n        down = 'bx;\n    end\nend\n\nalways @ (*) begin\n    if ((scancode_read_read_fu_52_p2 == 16'd57451)) begin\n        left_r = 3'd1;\n    end else if (((scancode_read_read_fu_52_p2 == 16'd57458) | (scancode_read_read_fu_52_p2 == 16'd57460) | (scancode_read_read_fu_52_p2 == 16'd57461) | (~(scancode_read_read_fu_52_p2 == 16'd57451) & ~(scancode_read_read_fu_52_p2 == 16'd57458) & ~(scancode_read_read_fu_52_p2 == 16'd57460) & ~(scancode_read_read_fu_52_p2 == 16'd57461)))) begin\n        left_r = 3'd0;\n    end else begin\n        left_r = 'bx;\n    end\nend\n\nalways @ (*) begin\n    if ((scancode_read_read_fu_52_p2 == 16'd57460)) begin\n        right_r = 1'd1;\n    end else if (((scancode_read_read_fu_52_p2 == 16'd57451) | (scancode_read_read_fu_52_p2 == 16'd57458) | (scancode_read_read_fu_52_p2 == 16'd57461) | (~(scancode_read_read_fu_52_p2 == 16'd57451) & ~(scancode_read_read_fu_52_p2 == 16'd57458) & ~(scancode_read_read_fu_52_p2 == 16'd57460) & ~(scancode_read_read_fu_52_p2 == 16'd57461)))) begin\n        right_r = 1'd0;\n    end else begin\n        right_r = 'bx;\n    end\nend\n\nalways @ (*) begin\n    if (((scancode_read_read_fu_52_p2 == 16'd57451) | (scancode_read_read_fu_52_p2 == 16'd57458) | (scancode_read_read_fu_52_p2 == 16'd57460) | (~(scancode_read_read_fu_52_p2 == 16'd57451) & ~(scancode_read_read_fu_52_p2 == 16'd57458) & ~(scancode_read_read_fu_52_p2 == 16'd57460) & ~(scancode_read_read_fu_52_p2 == 16'd57461)))) begin\n        up = 1'd0;\n    end else if ((scancode_read_read_fu_52_p2 == 16'd57461)) begin\n        up = 1'd1;\n    end else begin\n        up = 'bx;\n    end\nend\n\nassign scancode_read_read_fu_52_p2 = scancode;\n\nendmodule //always_nolatches", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [15:0] scancode, \n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start(\"Recognize arrow keys\");\n\t\t\t@(posedge clk) scancode <= 16'h0;\n\t\t\t@(posedge clk) scancode <= 16'h1;\n\t\t\t@(posedge clk) scancode <= 16'he075;\n\t\t\t@(posedge clk) scancode <= 16'he06b;\n\t\t\t@(posedge clk) scancode <= 16'he06c;\n\t\t\t@(posedge clk) scancode <= 16'he072;\n\t\t\t@(posedge clk) scancode <= 16'he074;\n\t\t\t@(posedge clk) scancode <= 16'he076;\n\t\t\t@(posedge clk) scancode <= 16'hffff;\n\t\t@(negedge clk) wavedrom_stop();\n\n\t\trepeat(30000) @(posedge clk, negedge clk) begin\n\t\t\tscancode <= $urandom;\n\t\tend\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_left;\n\t\tint errortime_left;\n\t\tint errors_down;\n\t\tint errortime_down;\n\t\tint errors_right;\n\t\tint errortime_right;\n\t\tint errors_up;\n\t\tint errortime_up;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [15:0] scancode;\n\tlogic left_ref;\n\tlogic left_dut;\n\tlogic down_ref;\n\tlogic down_dut;\n\tlogic right_ref;\n\tlogic right_dut;\n\tlogic up_ref;\n\tlogic up_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.scancode );\n\treference_module good1 (\n\t\t.scancode,\n\t\t.left(left_ref),\n\t\t.down(down_ref),\n\t\t.right(right_ref),\n\t\t.up(up_ref) );\n\t\t\n\talways_nolatches top_module1 (\n\t\t.scancode,\n\t\t.left_r(left_dut),\n\t\t.down(down_dut),\n\t\t.right_r(right_dut),\n\t\t.up(up_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_left) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"left\", stats1.errors_left, stats1.errortime_left);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"left\");\n\t\tif (stats1.errors_down) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"down\", stats1.errors_down, stats1.errortime_down);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"down\");\n\t\tif (stats1.errors_right) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"right\", stats1.errors_right, stats1.errortime_right);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"right\");\n\t\tif (stats1.errors_up) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"up\", stats1.errors_up, stats1.errortime_up);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"up\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { left_ref, down_ref, right_ref, up_ref } === ( { left_ref, down_ref, right_ref, up_ref } ^ { left_dut, down_dut, right_dut, up_dut } ^ { left_ref, down_ref, right_ref, up_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (left_ref !== ( left_ref ^ left_dut ^ left_ref ))\n\t\tbegin if (stats1.errors_left == 0) stats1.errortime_left = $time;\n\t\t\tstats1.errors_left = stats1.errors_left+1'b1; end\n\t\tif (down_ref !== ( down_ref ^ down_dut ^ down_ref ))\n\t\tbegin if (stats1.errors_down == 0) stats1.errortime_down = $time;\n\t\t\tstats1.errors_down = stats1.errors_down+1'b1; end\n\t\tif (right_ref !== ( right_ref ^ right_dut ^ right_ref ))\n\t\tbegin if (stats1.errors_right == 0) stats1.errortime_right = $time;\n\t\t\tstats1.errors_right = stats1.errors_right+1'b1; end\n\t\tif (up_ref !== ( up_ref ^ up_dut ^ up_ref ))\n\t\tbegin if (stats1.errors_up == 0) stats1.errortime_up = $time;\n\t\t\tstats1.errors_up = stats1.errors_up+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4a", "prompt": "module m2014_q4a (\n        d,\n        ena,\n        q\n);\n\n\ninput  [0:0] d;\ninput  [0:0] ena;\noutput  [0:0] q;", "canonical_solution": "wire   [0:0] ena_read_read_fu_30_p2;\nwire    ap_ce_reg;\n\nassign q = d;\n\nassign ena_read_read_fu_30_p2 = ena;\n\nendmodule //m2014_q4a", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n\talways@(*) begin\n\t\tif (ena)\n\t\t\tq = d;\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic d, ena\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{d,ena} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic d;\n\tlogic ena;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.ena );\n\treference_module good1 (\n\t\t.d,\n\t\t.ena,\n\t\t.q(q_ref) );\n\t\t\n\tm2014_q4a top_module1 (\n\t\t.d,\n\t\t.ena,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "kmap3", "prompt": "module kmap3 (\n        a,\n        b,\n        c,\n        d,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] out_r;", "canonical_solution": "reg[0:0] out_r;\n\nwire   [0:0] xor_ln8_fu_80_p2;\nwire   [0:0] or_ln6_fu_74_p2;\nwire   [0:0] or_ln12_fu_93_p2;\nwire   [0:0] or_ln11_fu_87_p2;\nwire   [0:0] or_ln15_fu_106_p2;\nwire   [0:0] and_ln18_fu_112_p2;\nwire   [0:0] xor_ln1019_fu_68_p2;\nwire   [0:0] xor_ln15_fu_100_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((((or_ln15_fu_106_p2 == 1'd1) & (or_ln11_fu_87_p2 == 1'd1) & (1'd1 == and_ln18_fu_112_p2) & (or_ln6_fu_74_p2 == 1'd1)) | ((or_ln15_fu_106_p2 == 1'd0) & (or_ln11_fu_87_p2 == 1'd1) & (or_ln6_fu_74_p2 == 1'd1)))) begin\n        out_r = 1'd1;\n    end else if (((or_ln11_fu_87_p2 == 1'd0) & (or_ln6_fu_74_p2 == 1'd1))) begin\n        out_r = or_ln12_fu_93_p2;\n    end else if ((or_ln6_fu_74_p2 == 1'd0)) begin\n        out_r = xor_ln8_fu_80_p2;\n    end else begin\n        out_r = 'bx;\n    end\nend\n\nassign and_ln18_fu_112_p2 = (xor_ln1019_fu_68_p2 & a);\n\nassign or_ln11_fu_87_p2 = (xor_ln1019_fu_68_p2 | a);\n\nassign or_ln12_fu_93_p2 = (d | c);\n\nassign or_ln15_fu_106_p2 = (xor_ln15_fu_100_p2 | xor_ln1019_fu_68_p2);\n\nassign or_ln6_fu_74_p2 = (b | a);\n\nassign xor_ln1019_fu_68_p2 = (b ^ 1'd1);\n\nassign xor_ln15_fu_100_p2 = (1'd1 ^ a);\n\nassign xor_ln8_fu_80_p2 = (d ^ c);\n\nendmodule //kmap3", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c,d} <= 4'b0;\n\t\twavedrom_start();\n\t\trepeat(16) @(posedge clk)\n\t\t\t{a,b,c,d} <= count++;\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref) );\n\t\t\n\tkmap3 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "norgate", "prompt": "module norgate (\n        a,\n        b,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] ret_V_fu_51_p2;\n\nassign ret_V_fu_51_p2 = (b | a);\n\nassign out_r = (ret_V_fu_51_p2 ^ 1'd1);\n\nendmodule //norgate", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a | b);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b} <= 1'b0;\n\t\twavedrom_start(\"NOR gate\");\n\t\trepeat(10) @(posedge clk)\n\t\t\t{a,b} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{b,a} <= $random;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.out(out_ref) );\n\t\t\n\tnorgate top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mt2015_q4a", "prompt": "module mt2015_q4a (\n        x,\n        y,\n        z\n);\n\n\ninput  [0:0] x;\ninput  [0:0] y;\noutput  [0:0] z;", "canonical_solution": "wire   [0:0] xor_ln1497_fu_51_p2;\n\nassign xor_ln1497_fu_51_p2 = (y ^ 1'd1);\n\nassign z = (xor_ln1497_fu_51_p2 & x);\n\nendmodule //mt2015_q4a", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) & x;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic x,\n\toutput logic y\n);\n\n\talways @(posedge clk, negedge clk)\n\t\t{x, y} <= $random % 4;\n\t\n\tinitial begin\n\t\trepeat(101) @(negedge clk);\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x;\n\tlogic y;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_ref) );\n\t\t\n\tmt2015_q4a top_module1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q3", "prompt": "module m2014_q3 (\n        x,\n        f\n);\n\n\ninput  [4:0] x;\noutput  [0:0] f;", "canonical_solution": "reg   [0:0] ap_phi_mux_storemerge1_phi_fu_68_p6;\nwire   [4:0] x_read_read_fu_52_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if (((x_read_read_fu_52_p2 == 5'd2) | ((x_read_read_fu_52_p2 == 5'd7) | ((x_read_read_fu_52_p2 == 5'd12) | (x_read_read_fu_52_p2 == 5'd11))))) begin\n        ap_phi_mux_storemerge1_phi_fu_68_p6 = 1'd1;\n    end else if (((x_read_read_fu_52_p2 == 5'd1) | (x_read_read_fu_52_p2 == 5'd10) | (x_read_read_fu_52_p2 == 5'd9) | (x_read_read_fu_52_p2 == 5'd8) | (x_read_read_fu_52_p2 == 5'd6) | (x_read_read_fu_52_p2 == 5'd4) | (~(x_read_read_fu_52_p2 == 5'd12) & ~(x_read_read_fu_52_p2 == 5'd11) & ~(x_read_read_fu_52_p2 == 5'd7) & ~(x_read_read_fu_52_p2 == 5'd2) & ~(x_read_read_fu_52_p2 == 5'd10) & ~(x_read_read_fu_52_p2 == 5'd9) & ~(x_read_read_fu_52_p2 == 5'd8) & ~(x_read_read_fu_52_p2 == 5'd6) & ~(x_read_read_fu_52_p2 == 5'd4) & ~(x_read_read_fu_52_p2 == 5'd1)))) begin\n        ap_phi_mux_storemerge1_phi_fu_68_p6 = 1'd0;\n    end else begin\n        ap_phi_mux_storemerge1_phi_fu_68_p6 = 'bx;\n    end\nend\n\nassign f = ap_phi_mux_storemerge1_phi_fu_68_p6;\n\nassign x_read_read_fu_52_p2 = x;\n\nendmodule //m2014_q3", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx;\n\t\t\t4'h1: f = 1'bx;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 1'bx;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1'bx;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 1'bx;\n\t\t\t4'hb: f = 1;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 1'bx;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [4:1] x\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tx <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_f;\n\t\tint errortime_f;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [4:1] x;\n\tlogic f_ref;\n\tlogic f_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x );\n\treference_module good1 (\n\t\t.x,\n\t\t.f(f_ref) );\n\t\t\n\tm2014_q3 top_module1 (\n\t\t.x,\n\t\t.f(f_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_f) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"f\", stats1.errors_f, stats1.errortime_f);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"f\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { f_ref } === ( { f_ref } ^ { f_dut } ^ { f_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (f_ref !== ( f_ref ^ f_dut ^ f_ref ))\n\t\tbegin if (stats1.errors_f == 0) stats1.errortime_f = $time;\n\t\t\tstats1.errors_f = stats1.errors_f+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vectorr", "prompt": "module vectorr (\n        in_r,\n        out_r\n);\n\n\ninput  [7:0] in_r;\noutput reg [7:0] out_r;", "canonical_solution": "assign out_r = in_r;\n\nendmodule //vectorr", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\t\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) in <= 8'h1;\n\t\t\t@(posedge clk) in <= 8'h2;\n\t\t\t@(posedge clk) in <= 8'h4;\n\t\t\t@(posedge clk) in <= 8'h8;\n\t\t\t@(posedge clk) in <= 8'h80;\n\t\t\t@(posedge clk) in <= 8'hc0;\n\t\t\t@(posedge clk) in <= 8'he0;\n\t\t\t@(posedge clk) in <= 8'hf0;\n\t\t@(negedge clk) wavedrom_stop();\n\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic [7:0] out_ref;\n\tlogic [7:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tvectorr top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4i", "prompt": "module m2014_q4i (\n        out_r\n);\n\n\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = 1'd0;\n\nendmodule //m2014_q4i", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.*  );\n\treference_module good1 (\n\t\t.out(out_ref) );\n\t\t\n\tm2014_q4i top_module1 (\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "always_case", "prompt": "module always_case (\n        sel,\n        data0,\n        data1,\n        data2,\n        data3,\n        data4,\n        data5,\n        out_r\n);\n\n\ninput  [2:0] sel;\ninput  [3:0] data0;\ninput  [3:0] data1;\ninput  [3:0] data2;\ninput  [3:0] data3;\ninput  [3:0] data4;\ninput  [3:0] data5;\noutput  [3:0] out_r;", "canonical_solution": "reg[3:0] out_r;\n\nwire   [2:0] sel_read_read_fu_92_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if (((sel_read_read_fu_92_p2 == 3'd6) | (sel_read_read_fu_92_p2 == 3'd7))) begin\n        out_r = 4'd0;\n    end else if ((sel_read_read_fu_92_p2 == 3'd0)) begin\n        out_r = data0;\n    end else if ((sel_read_read_fu_92_p2 == 3'd1)) begin\n        out_r = data1;\n    end else if ((sel_read_read_fu_92_p2 == 3'd2)) begin\n        out_r = data2;\n    end else if ((sel_read_read_fu_92_p2 == 3'd3)) begin\n        out_r = data3;\n    end else if ((sel_read_read_fu_92_p2 == 3'd4)) begin\n        out_r = data4;\n    end else if ((sel_read_read_fu_92_p2 == 3'd5)) begin\n        out_r = data5;\n    end else begin\n        out_r = 'bx;\n    end\nend\n\nassign sel_read_read_fu_92_p2 = sel;\n\nendmodule //always_case", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [2:0] sel, \n\toutput logic [3:0] data0,\n\toutput logic [3:0] data1,\n\toutput logic [3:0] data2,\n\toutput logic [3:0] data3,\n\toutput logic [3:0] data4,\n\toutput logic [3:0] data5,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tdata0 <= 4'ha;\n\t\tdata1 <= 4'hb;\n\t\tdata2 <= 4'hc;\n\t\tdata3 <= 4'hd;\n\t\tdata4 <= 4'he;\n\t\tdata5 <= 4'hf;\n\t\t{sel} <= 3'b111;\n\t\t@(negedge clk) wavedrom_start(\"<b>Sel</b> chooses one of the data inputs\");\n\t\t\trepeat(8) @(posedge clk) sel <= sel + 1;\n\t\t@(negedge clk) wavedrom_stop();\n\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{data0, data1, data2, data3} <= $urandom;\n\t\t\t{data4, data5, sel} <= $urandom;\n\t\tend\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] sel;\n\tlogic [3:0] data0;\n\tlogic [3:0] data1;\n\tlogic [3:0] data2;\n\tlogic [3:0] data3;\n\tlogic [3:0] data4;\n\tlogic [3:0] data5;\n\tlogic [3:0] out_ref;\n\tlogic [3:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5 );\n\treference_module good1 (\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5,\n\t\t.out(out_ref) );\n\t\t\n\talways_case top_module1 (\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mux2to1v", "prompt": "module mux2to1v (\n        a,\n        b,\n        sel,\n        out_r\n);\n\n\ninput  [99:0] a;\ninput  [99:0] b;\ninput  [0:0] sel;\noutput  [99:0] out_r;", "canonical_solution": "assign out_r = ((sel[0:0] == 1'b1) ? b : a);\n\nendmodule //mux2to1v", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [99:0] a,b,\n\toutput logic sel,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\ta <= 'hdeadbeef;\n\t\tb <= 'h5eaf00d;\n\t\tsel <= 0;\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Beef or seafood?\");\n\t\t\trepeat(6) @(posedge clk) sel <= ~sel;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel} <= {$random, $random, $random, $random, $random, $random, $random};\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [99:0] a;\n\tlogic [99:0] b;\n\tlogic sel;\n\tlogic [99:0] out_ref;\n\tlogic [99:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\tmux2to1v top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "fsm3comb", "prompt": "module fsm3comb (\n        in_r,\n        state,\n        next_state,\n        out_r\n);\n\n\ninput  [0:0] in_r;\ninput  [1:0] state;\noutput  [1:0] next_state;\noutput  [0:0] out_r;", "canonical_solution": "reg[1:0] next_state;\nreg[0:0] out_r;\n\nwire   [1:0] state_read_read_fu_48_p2;\nwire   [1:0] select_ln17_fu_91_p3;\nwire   [1:0] grp_fu_76_p3;\nwire   [1:0] select_ln214_1_fu_100_p3;\nwire   [0:0] xor_ln214_fu_85_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((state_read_read_fu_48_p2 == 2'd0)) begin\n        next_state = select_ln214_1_fu_100_p3;\n    end else if (((state_read_read_fu_48_p2 == 2'd3) | (state_read_read_fu_48_p2 == 2'd1))) begin\n        next_state = grp_fu_76_p3;\n    end else if ((state_read_read_fu_48_p2 == 2'd2)) begin\n        next_state = select_ln17_fu_91_p3;\n    end else begin\n        next_state = 'bx;\n    end\nend\n\nalways @ (*) begin\n    if ((state_read_read_fu_48_p2 == 2'd3)) begin\n        out_r = 1'd1;\n    end else if (((state_read_read_fu_48_p2 == 2'd0) | (state_read_read_fu_48_p2 == 2'd1) | (state_read_read_fu_48_p2 == 2'd2))) begin\n        out_r = 1'd0;\n    end else begin\n        out_r = 'bx;\n    end\nend\n\nassign grp_fu_76_p3 = ((in_r[0:0] == 1'b1) ? 2'd2 : 2'd1);\n\nassign select_ln17_fu_91_p3 = ((xor_ln214_fu_85_p2[0:0] == 1'b1) ? 2'd3 : 2'd0);\n\nassign select_ln214_1_fu_100_p3 = ((in_r[0:0] == 1'b1) ? 2'd1 : 2'd2);\n\nassign xor_ln214_fu_85_p2 = (in_r ^ 1'd1);\n\nassign state_read_read_fu_48_p2 = state;\n\nendmodule //fsm3comb", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in,\n\toutput logic [1:0] state\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tin <= $random;\n\t\t\tstate <= $random;\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_next_state;\n\t\tint errortime_next_state;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic [1:0] state;\n\tlogic [1:0] next_state_ref;\n\tlogic [1:0] next_state_dut;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.state );\n\treference_module good1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_ref),\n\t\t.out(out_ref) );\n\t\t\n\tfsm3comb top_module1 (\n\t\t.in_r(in),\n\t\t.state,\n\t\t.next_state(next_state_dut),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_next_state) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"next_state\", stats1.errors_next_state, stats1.errortime_next_state);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"next_state\");\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { next_state_ref, out_ref } === ( { next_state_ref, out_ref } ^ { next_state_dut, out_dut } ^ { next_state_ref, out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (next_state_ref !== ( next_state_ref ^ next_state_dut ^ next_state_ref ))\n\t\tbegin if (stats1.errors_next_state == 0) stats1.errortime_next_state = $time;\n\t\t\tstats1.errors_next_state = stats1.errors_next_state+1'b1; end\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "gates100", "prompt": "module gates100 (\n        in_r,\n        out_and,\n        out_or,\n        out_xor\n);\n\n\ninput  [99:0] in_r;\noutput  [0:0] out_and;\noutput  [0:0] out_or;\noutput  [0:0] out_xor;", "canonical_solution": "assign out_and = ((in_r == 100'd1267650600228229401496703205375) ? 1'b1 : 1'b0);\n\nassign out_or = ((in_r != 100'd0) ? 1'b1 : 1'b0);\n\nassign out_xor = ^(in_r);\n\nendmodule //gates100", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput logic [99:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\treg [3:0] count; count = 0;\n\t\tin <= 100'h0;\n\t\t// AND gate uses huge numbers and creates a sparse waveform.\n\t\t@(negedge clk) wavedrom_start(\"Test AND gate\");\n\t\t\t@(posedge clk,negedge clk) in <= 100'h0;\t\t// Test OR gate\n\t\t\t@(posedge clk,negedge clk); in <= ~100'h0;\t\t// Test AND gate\n\t\t\t@(posedge clk,negedge clk); in <= 100'h3ffff;\t\n\t\t\t@(posedge clk,negedge clk); in <= ~100'h3ffff;\t\n\t\t\t@(posedge clk,negedge clk); in <= 100'h80;\t\t\n\t\t\t@(posedge clk,negedge clk); in <= ~100'h80;\t\t\n\t\twavedrom_stop();\n\n\t\t@(negedge clk) wavedrom_start(\"Test OR and XOR gates\");\n\t\t\t@(posedge clk) in <= 100'h0;\t\t// Test OR gate\n\t\t\t@(posedge clk); in <= 100'h7;\t\t// Test AND gate\n\t\t\trepeat(10) @(posedge clk, negedge clk) begin\n\t\t\t\tin <= count;\t\t\n\t\t\t\tcount <= count + 1;\n\t\t\tend\n\t\t\t@(posedge clk) in <= 100'h0;\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\tin <= $random;\n\t\trepeat(100) begin\n\t\t\t@(negedge clk) in <= $random;\n\t\t\t@(posedge clk) in <= $random;\n\t\tend\n\t\tfor (int i=0;i<100;i++) begin\n\t\t\t@(negedge clk) in <= 100'h1<<i;\n\t\t\t@(posedge clk) in <= ~(100'h1<<i);\n\t\tend\n\t\t@(posedge clk) in <= 100'h0;\t\t// Test OR gate\n\t\t@(posedge clk); in <= ~100'h0;\t\t// Test AND gate\n\t\t@(posedge clk);\n\t\t#1 $finish;\n\tend\n\t\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_and;\n\t\tint errortime_out_and;\n\t\tint errors_out_or;\n\t\tint errortime_out_or;\n\t\tint errors_out_xor;\n\t\tint errortime_out_xor;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [99:0] in;\n\tlogic out_and_ref;\n\tlogic out_and_dut;\n\tlogic out_or_ref;\n\tlogic out_or_dut;\n\tlogic out_xor_ref;\n\tlogic out_xor_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_and(out_and_ref),\n\t\t.out_or(out_or_ref),\n\t\t.out_xor(out_xor_ref) );\n\t\t\n\tgates100 top_module1 (\n\t\t.in_r(in),\n\t\t.out_and(out_and_dut),\n\t\t.out_or(out_or_dut),\n\t\t.out_xor(out_xor_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_and) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_and\", stats1.errors_out_and, stats1.errortime_out_and);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_and\");\n\t\tif (stats1.errors_out_or) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or\", stats1.errors_out_or, stats1.errortime_out_or);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or\");\n\t\tif (stats1.errors_out_xor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_xor\", stats1.errors_out_xor, stats1.errortime_out_xor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_xor\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_and_ref, out_or_ref, out_xor_ref } === ( { out_and_ref, out_or_ref, out_xor_ref } ^ { out_and_dut, out_or_dut, out_xor_dut } ^ { out_and_ref, out_or_ref, out_xor_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_and_ref !== ( out_and_ref ^ out_and_dut ^ out_and_ref ))\n\t\tbegin if (stats1.errors_out_and == 0) stats1.errortime_out_and = $time;\n\t\t\tstats1.errors_out_and = stats1.errors_out_and+1'b1; end\n\t\tif (out_or_ref !== ( out_or_ref ^ out_or_dut ^ out_or_ref ))\n\t\tbegin if (stats1.errors_out_or == 0) stats1.errortime_out_or = $time;\n\t\t\tstats1.errors_out_or = stats1.errors_out_or+1'b1; end\n\t\tif (out_xor_ref !== ( out_xor_ref ^ out_xor_dut ^ out_xor_ref ))\n\t\tbegin if (stats1.errors_out_xor == 0) stats1.errortime_out_xor = $time;\n\t\t\tstats1.errors_out_xor = stats1.errors_out_xor+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "circuit2", "prompt": "module circuit2 (\n        a,\n        b,\n        c,\n        d,\n        q\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] q;", "canonical_solution": "wire   [0:0] xor_ln6_2_fu_79_p2;\nwire   [0:0] and_ln6_fu_85_p2;\nwire   [0:0] and_ln6_2_fu_97_p2;\nwire   [0:0] xor_ln6_1_fu_73_p2;\nwire   [0:0] xor_ln901_fu_109_p2;\nwire   [0:0] and_ln6_5_fu_121_p2;\nwire   [0:0] xor_ln6_fu_67_p2;\nwire   [0:0] and_ln6_1_fu_91_p2;\nwire   [0:0] and_ln6_3_fu_103_p2;\nwire   [0:0] and_ln6_4_fu_115_p2;\nwire   [0:0] and_ln6_6_fu_127_p2;\nwire   [0:0] or_ln6_1_fu_139_p2;\nwire   [0:0] or_ln6_fu_133_p2;\n\nassign and_ln6_1_fu_91_p2 = (b & and_ln6_fu_85_p2);\n\nassign and_ln6_2_fu_97_p2 = (d & b);\n\nassign and_ln6_3_fu_103_p2 = (xor_ln6_1_fu_73_p2 & and_ln6_2_fu_97_p2);\n\nassign and_ln6_4_fu_115_p2 = (xor_ln901_fu_109_p2 & c);\n\nassign and_ln6_5_fu_121_p2 = (d & a);\n\nassign and_ln6_6_fu_127_p2 = (xor_ln6_fu_67_p2 & and_ln6_5_fu_121_p2);\n\nassign and_ln6_fu_85_p2 = (xor_ln6_2_fu_79_p2 & c);\n\nassign or_ln6_1_fu_139_p2 = (and_ln6_6_fu_127_p2 | and_ln6_4_fu_115_p2);\n\nassign or_ln6_fu_133_p2 = (and_ln6_3_fu_103_p2 | and_ln6_1_fu_91_p2);\n\nassign xor_ln6_1_fu_73_p2 = (c ^ 1'd1);\n\nassign xor_ln6_2_fu_79_p2 = (1'd1 ^ a);\n\nassign xor_ln6_fu_67_p2 = (b ^ 1'd1);\n\nassign xor_ln901_fu_109_p2 = (d ^ 1'd1);\n\nassign q = (or_ln6_fu_133_p2 | or_ln6_1_fu_139_p2);\n\nendmodule //circuit2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c^d;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,c,d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b,c,d} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b,c,d} <= 0;\n\t\t\trepeat(18) @(posedge clk, negedge clk) {a,b,c,d} <= {a,b,c,d} + 1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit2 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4g", "prompt": "module m2014_q4g (\n        in1,\n        in2,\n        in3,\n        out_r\n);\n\n\ninput  [0:0] in1;\ninput  [0:0] in2;\ninput  [0:0] in3;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] xor_ln1499_1_fu_65_p2;\nwire   [0:0] xor_ln1499_fu_59_p2;\n\nassign xor_ln1499_1_fu_65_p2 = (in3 ^ in2);\n\nassign xor_ln1499_fu_59_p2 = (in1 ^ 1'd1);\n\nassign out_r = (xor_ln1499_fu_59_p2 ^ xor_ln1499_1_fu_65_p2);\n\nendmodule //m2014_q4g", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ^ in3;\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in1, in2, in3\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{in1, in2, in3} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in1;\n\tlogic in2;\n\tlogic in3;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in1,\n\t\t.in2,\n\t\t.in3 );\n\treference_module good1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.in3,\n\t\t.out(out_ref) );\n\t\t\n\tm2014_q4g top_module1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.in3,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "gates", "prompt": "module gates (\n        a,\n        b,\n        out_and,\n        out_or,\n        out_xor,\n        out_nand,\n        out_nor,\n        out_xnor,\n        out_anotb\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] out_and;\noutput  [0:0] out_or;\noutput  [0:0] out_xor;\noutput  [0:0] out_nand;\noutput  [0:0] out_nor;\noutput  [0:0] out_xnor;\noutput  [0:0] out_anotb;", "canonical_solution": "wire   [0:0] ret_V_fu_105_p2;\nwire   [0:0] ret_V_1_fu_112_p2;\nwire   [0:0] ret_V_2_fu_119_p2;\nwire   [0:0] r_V_4_fu_147_p2;\n\nassign r_V_4_fu_147_p2 = (b ^ 1'd1);\n\nassign ret_V_1_fu_112_p2 = (b | a);\n\nassign ret_V_2_fu_119_p2 = (b ^ a);\n\nassign ret_V_fu_105_p2 = (b & a);\n\nassign out_and = ret_V_fu_105_p2;\n\nassign out_anotb = (r_V_4_fu_147_p2 & a);\n\nassign out_nand = (ret_V_fu_105_p2 ^ 1'd1);\n\nassign out_nor = (ret_V_1_fu_112_p2 ^ 1'd1);\n\nassign out_or = ret_V_1_fu_112_p2;\n\nassign out_xnor = (ret_V_2_fu_119_p2 ^ 1'd1);\n\nassign out_xor = ret_V_2_fu_119_p2;\n\nendmodule //gates", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a^~b;\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\t\n\tinitial begin\n\t\t@(negedge clk) {a,b} <= 0;\n\t\twavedrom_start();\n\t\t\t@(posedge clk) {a,b} <= 0;\n\t\t\t@(posedge clk) {a,b} <= 1;\n\t\t\t@(posedge clk) {a,b} <= 2;\n\t\t\t@(posedge clk) {a,b} <= 3;\n\t\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t{a,b} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_and;\n\t\tint errortime_out_and;\n\t\tint errors_out_or;\n\t\tint errortime_out_or;\n\t\tint errors_out_xor;\n\t\tint errortime_out_xor;\n\t\tint errors_out_nand;\n\t\tint errortime_out_nand;\n\t\tint errors_out_nor;\n\t\tint errortime_out_nor;\n\t\tint errors_out_xnor;\n\t\tint errortime_out_xnor;\n\t\tint errors_out_anotb;\n\t\tint errortime_out_anotb;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic out_and_ref;\n\tlogic out_and_dut;\n\tlogic out_or_ref;\n\tlogic out_or_dut;\n\tlogic out_xor_ref;\n\tlogic out_xor_dut;\n\tlogic out_nand_ref;\n\tlogic out_nand_dut;\n\tlogic out_nor_ref;\n\tlogic out_nor_dut;\n\tlogic out_xnor_ref;\n\tlogic out_xnor_dut;\n\tlogic out_anotb_ref;\n\tlogic out_anotb_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_and(out_and_ref),\n\t\t.out_or(out_or_ref),\n\t\t.out_xor(out_xor_ref),\n\t\t.out_nand(out_nand_ref),\n\t\t.out_nor(out_nor_ref),\n\t\t.out_xnor(out_xnor_ref),\n\t\t.out_anotb(out_anotb_ref) );\n\t\t\n\tgates top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_and(out_and_dut),\n\t\t.out_or(out_or_dut),\n\t\t.out_xor(out_xor_dut),\n\t\t.out_nand(out_nand_dut),\n\t\t.out_nor(out_nor_dut),\n\t\t.out_xnor(out_xnor_dut),\n\t\t.out_anotb(out_anotb_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_and) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_and\", stats1.errors_out_and, stats1.errortime_out_and);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_and\");\n\t\tif (stats1.errors_out_or) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or\", stats1.errors_out_or, stats1.errortime_out_or);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or\");\n\t\tif (stats1.errors_out_xor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_xor\", stats1.errors_out_xor, stats1.errortime_out_xor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_xor\");\n\t\tif (stats1.errors_out_nand) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_nand\", stats1.errors_out_nand, stats1.errortime_out_nand);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_nand\");\n\t\tif (stats1.errors_out_nor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_nor\", stats1.errors_out_nor, stats1.errortime_out_nor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_nor\");\n\t\tif (stats1.errors_out_xnor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_xnor\", stats1.errors_out_xnor, stats1.errortime_out_xnor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_xnor\");\n\t\tif (stats1.errors_out_anotb) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_anotb\", stats1.errors_out_anotb, stats1.errortime_out_anotb);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_anotb\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_and_ref, out_or_ref, out_xor_ref, out_nand_ref, out_nor_ref, out_xnor_ref, out_anotb_ref } === ( { out_and_ref, out_or_ref, out_xor_ref, out_nand_ref, out_nor_ref, out_xnor_ref, out_anotb_ref } ^ { out_and_dut, out_or_dut, out_xor_dut, out_nand_dut, out_nor_dut, out_xnor_dut, out_anotb_dut } ^ { out_and_ref, out_or_ref, out_xor_ref, out_nand_ref, out_nor_ref, out_xnor_ref, out_anotb_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_and_ref !== ( out_and_ref ^ out_and_dut ^ out_and_ref ))\n\t\tbegin if (stats1.errors_out_and == 0) stats1.errortime_out_and = $time;\n\t\t\tstats1.errors_out_and = stats1.errors_out_and+1'b1; end\n\t\tif (out_or_ref !== ( out_or_ref ^ out_or_dut ^ out_or_ref ))\n\t\tbegin if (stats1.errors_out_or == 0) stats1.errortime_out_or = $time;\n\t\t\tstats1.errors_out_or = stats1.errors_out_or+1'b1; end\n\t\tif (out_xor_ref !== ( out_xor_ref ^ out_xor_dut ^ out_xor_ref ))\n\t\tbegin if (stats1.errors_out_xor == 0) stats1.errortime_out_xor = $time;\n\t\t\tstats1.errors_out_xor = stats1.errors_out_xor+1'b1; end\n\t\tif (out_nand_ref !== ( out_nand_ref ^ out_nand_dut ^ out_nand_ref ))\n\t\tbegin if (stats1.errors_out_nand == 0) stats1.errortime_out_nand = $time;\n\t\t\tstats1.errors_out_nand = stats1.errors_out_nand+1'b1; end\n\t\tif (out_nor_ref !== ( out_nor_ref ^ out_nor_dut ^ out_nor_ref ))\n\t\tbegin if (stats1.errors_out_nor == 0) stats1.errortime_out_nor = $time;\n\t\t\tstats1.errors_out_nor = stats1.errors_out_nor+1'b1; end\n\t\tif (out_xnor_ref !== ( out_xnor_ref ^ out_xnor_dut ^ out_xnor_ref ))\n\t\tbegin if (stats1.errors_out_xnor == 0) stats1.errortime_out_xnor = $time;\n\t\t\tstats1.errors_out_xnor = stats1.errors_out_xnor+1'b1; end\n\t\tif (out_anotb_ref !== ( out_anotb_ref ^ out_anotb_dut ^ out_anotb_ref ))\n\t\tbegin if (stats1.errors_out_anotb == 0) stats1.errortime_out_anotb = $time;\n\t\t\tstats1.errors_out_anotb = stats1.errors_out_anotb+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "fsm3onehot", "prompt": "module fsm3onehot (\n        in_r,\n        state,\n        next_state,\n        out_r\n);\n\n\ninput  [0:0] in_r;\ninput  [3:0] state;\noutput  [3:0] next_state;\noutput  [0:0] out_r;", "canonical_solution": "reg[3:0] next_state;\nreg[0:0] out_r;\n\nwire   [3:0] state_read_read_fu_48_p2;\nwire   [3:0] select_ln22_fu_77_p3;\nwire   [3:0] select_ln214_fu_86_p3;\nwire   [3:0] select_ln14_fu_95_p3;\nwire   [3:0] select_ln10_fu_104_p3;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((~(state_read_read_fu_48_p2 == 4'd1) & ~(state_read_read_fu_48_p2 == 4'd2) & ~(state_read_read_fu_48_p2 == 4'd4) & ~(state_read_read_fu_48_p2 == 4'd8))) begin\n        next_state = state;\n    end else if ((state_read_read_fu_48_p2 == 4'd1)) begin\n        next_state = select_ln10_fu_104_p3;\n    end else if ((state_read_read_fu_48_p2 == 4'd2)) begin\n        next_state = select_ln14_fu_95_p3;\n    end else if ((state_read_read_fu_48_p2 == 4'd4)) begin\n        next_state = select_ln214_fu_86_p3;\n    end else if ((state_read_read_fu_48_p2 == 4'd8)) begin\n        next_state = select_ln22_fu_77_p3;\n    end else begin\n        next_state = 'bx;\n    end\nend\n\nalways @ (*) begin\n    if (((state_read_read_fu_48_p2 == 4'd1) | (state_read_read_fu_48_p2 == 4'd2) | (state_read_read_fu_48_p2 == 4'd4) | (~(state_read_read_fu_48_p2 == 4'd1) & ~(state_read_read_fu_48_p2 == 4'd2) & ~(state_read_read_fu_48_p2 == 4'd4) & ~(state_read_read_fu_48_p2 == 4'd8)))) begin\n        out_r = 1'd0;\n    end else if ((state_read_read_fu_48_p2 == 4'd8)) begin\n        out_r = 1'd1;\n    end else begin\n        out_r = 'bx;\n    end\nend\n\nassign select_ln10_fu_104_p3 = ((in_r[0:0] == 1'b1) ? 4'd2 : 4'd1);\n\nassign select_ln14_fu_95_p3 = ((in_r[0:0] == 1'b1) ? 4'd2 : 4'd4);\n\nassign select_ln214_fu_86_p3 = ((in_r[0:0] == 1'b1) ? 4'd1 : 4'd8);\n\nassign select_ln22_fu_77_p3 = ((in_r[0:0] == 1'b1) ? 4'd4 : 4'd2);\n\nassign state_read_read_fu_48_p2 = state;\n\nendmodule //fsm3onehot", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in;\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in;\n    assign next_state[C] = (state[B] | state[D]) & ~in;\n    assign next_state[D] = state[C] & in;\n    \n\tassign out = (state[D]);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in,\n\toutput logic [3:0] state,\n\tinput tb_match\n);\n\n\tint errored1 = 0;\n\tint onehot_error = 0;\n\t\n\tinitial begin\n\t\t// Test the one-hot cases first.\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\tstate <= 1<< ($unsigned($random) % 4);\n\t\t\tin <= $random;\n\t\t\tif (!tb_match) onehot_error++;\n\t\tend\n\t\t\t\n\t\t\t\n\t\t// Random.\n\t\terrored1 = 0;\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tstate <= $random;\n\t\t\tin <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored1++;\n\t\tend\n\t\tif (!onehot_error && errored1) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with random inputs.\");\n\n\t\tif (!onehot_error && errored1)\n\t\t\t$display(\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_next_state;\n\t\tint errortime_next_state;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic [3:0] state;\n\tlogic [3:0] next_state_ref;\n\tlogic [3:0] next_state_dut;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.state );\n\treference_module good1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_ref),\n\t\t.out(out_ref) );\n\t\t\n\tfsm3onehot top_module1 (\n\t\t.in_r(in),\n\t\t.state,\n\t\t.next_state(next_state_dut),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_next_state) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"next_state\", stats1.errors_next_state, stats1.errortime_next_state);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"next_state\");\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { next_state_ref, out_ref } === ( { next_state_ref, out_ref } ^ { next_state_dut, out_dut } ^ { next_state_ref, out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (next_state_ref !== ( next_state_ref ^ next_state_dut ^ next_state_ref ))\n\t\tbegin if (stats1.errors_next_state == 0) stats1.errortime_next_state = $time;\n\t\t\tstats1.errors_next_state = stats1.errors_next_state+1'b1; end\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "kmap4", "prompt": "module kmap4 (\n        a,\n        b,\n        c,\n        d,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] ret_V_5_fu_65_p2;\nwire   [0:0] ret_V_6_fu_71_p2;\nwire   [0:0] ret_V_7_fu_77_p2;\nwire   [0:0] ret_V_8_fu_83_p2;\nwire   [0:0] or_ln1498_1_fu_95_p2;\nwire   [0:0] or_ln1498_fu_89_p2;\n\nassign or_ln1498_1_fu_95_p2 = (ret_V_8_fu_83_p2 | ret_V_7_fu_77_p2);\n\nassign or_ln1498_fu_89_p2 = (ret_V_6_fu_71_p2 | ret_V_5_fu_65_p2);\n\nassign ret_V_5_fu_65_p2 = (d & c);\n\nassign ret_V_6_fu_71_p2 = (b & a);\n\nassign ret_V_7_fu_77_p2 = (c & a);\n\nassign ret_V_8_fu_83_p2 = (d & b);\n\nassign out_r = (or_ln1498_fu_89_p2 | or_ln1498_1_fu_95_p2);\n\nendmodule //kmap4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c,d} <= 4'b0;\n\t\twavedrom_start();\n\t\trepeat(16) @(posedge clk)\n\t\t\t{a,b,c,d} <= count++;\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref) );\n\t\t\n\tkmap4 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "a7458", "prompt": "module a7458 (\n        p1a,\n        p1b,\n        p1c,\n        p1d,\n        p1e,\n        p1f,\n        p1y,\n        p2a,\n        p2b,\n        p2c,\n        p2d,\n        p2y\n);\n\ninput  [0:0] p1a;\ninput  [0:0] p1b;\ninput  [0:0] p1c;\ninput  [0:0] p1d;\ninput  [0:0] p1e;\ninput  [0:0] p1f;\noutput  [0:0] p1y;\ninput  [0:0] p2a;\ninput  [0:0] p2b;\ninput  [0:0] p2c;\ninput  [0:0] p2d;\noutput  [0:0] p2y;", "canonical_solution": "wire   [0:0] and_ln1497_fu_122_p2;\nwire   [0:0] and_ln1497_2_fu_134_p2;\nwire   [0:0] ret_V_fu_128_p2;\nwire   [0:0] ret_V_1_fu_140_p2;\nwire   [0:0] ret_V_3_fu_153_p2;\nwire   [0:0] ret_V_4_fu_159_p2;\n\nassign and_ln1497_2_fu_134_p2 = (p1f & p1e);\n\nassign and_ln1497_fu_122_p2 = (p1c & p1b);\n\nassign ret_V_1_fu_140_p2 = (p1d & and_ln1497_2_fu_134_p2);\n\nassign ret_V_3_fu_153_p2 = (p2b & p2a);\n\nassign ret_V_4_fu_159_p2 = (p2d & p2c);\n\nassign ret_V_fu_128_p2 = (p1a & and_ln1497_fu_122_p2);\n\nassign p1y = (ret_V_fu_128_p2 | ret_V_1_fu_140_p2);\n\nassign p2y = (ret_V_4_fu_159_p2 | ret_V_3_fu_153_p2);\n\nendmodule //a7458", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg p1a, p1b, p1c, p1d, p1e, p1f,\n\toutput reg p2a, p2b, p2c, p2d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{p1a,p1b,p1c,p1d,p1e,p1f} <= 4'h0;\t\t\n\t\t{p2a,p2b,p2c,p2d} <= 4'h0;\t\t\n\t\twavedrom_start();\n\t\trepeat(20) @(posedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d,p1e,p1f} <= {count[2:0], count[3:1]};\t\t\n\t\t\t{p2a,p2b,p2c,p2d} <= count;\t\t\n\t\t\tcount = count + 1;\n\t\tend\n\t\twavedrom_stop();\n\n\t\trepeat(400) @(posedge clk,negedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d,p2a,p2b,p2c,p2d} <= $random;\t\t\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_p1y;\n\t\tint errortime_p1y;\n\t\tint errors_p2y;\n\t\tint errortime_p2y;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic p1a;\n\tlogic p1b;\n\tlogic p1c;\n\tlogic p1d;\n\tlogic p1e;\n\tlogic p1f;\n\tlogic p2a;\n\tlogic p2b;\n\tlogic p2c;\n\tlogic p2d;\n\tlogic p1y_ref;\n\tlogic p1y_dut;\n\tlogic p2y_ref;\n\tlogic p2y_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d );\n\treference_module good1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_ref),\n\t\t.p2y(p2y_ref) );\n\t\t\n\ta7458 top_module1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_dut),\n\t\t.p2y(p2y_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_p1y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p1y\", stats1.errors_p1y, stats1.errortime_p1y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p1y\");\n\t\tif (stats1.errors_p2y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p2y\", stats1.errors_p2y, stats1.errortime_p2y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p2y\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { p1y_ref, p2y_ref } === ( { p1y_ref, p2y_ref } ^ { p1y_dut, p2y_dut } ^ { p1y_ref, p2y_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (p1y_ref !== ( p1y_ref ^ p1y_dut ^ p1y_ref ))\n\t\tbegin if (stats1.errors_p1y == 0) stats1.errortime_p1y = $time;\n\t\t\tstats1.errors_p1y = stats1.errors_p1y+1'b1; end\n\t\tif (p2y_ref !== ( p2y_ref ^ p2y_dut ^ p2y_ref ))\n\t\tbegin if (stats1.errors_p2y == 0) stats1.errortime_p2y = $time;\n\t\t\tstats1.errors_p2y = stats1.errors_p2y+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4h", "prompt": "module m2014_q4h (\n        in_r,\n        out_r\n);\n\n\ninput  [0:0] in_r;\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = in_r;\n\nendmodule //m2014_q4h", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg in = 0\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tin <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tm2014_q4h top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "andgate", "prompt": "module andgate (\n        a,\n        b,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = (b & a);\n\nendmodule //andgate", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = a & b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b} <= 1'b0;\n\t\twavedrom_start(\"AND gate\");\n\t\trepeat(10) @(posedge clk)\n\t\t\t{a,b} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{b,a} <= $random;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.out(out_ref) );\n\t\t\n\tandgate top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vector5", "prompt": "module vector5 (\n        a,\n        b,\n        c,\n        d,\n        e,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\ninput  [0:0] e;\noutput  [24:0] out_r;", "canonical_solution": "wire   [0:0] r_V_fu_77_p2;\nwire   [0:0] r_V_1_fu_107_p2;\nwire   [0:0] r_V_2_fu_137_p2;\nwire   [0:0] r_V_3_fu_167_p2;\nwire   [0:0] r_V_4_fu_197_p2;\nwire   [0:0] ret_V_fu_83_p2;\nwire   [0:0] ret_V_1_fu_89_p2;\nwire   [0:0] ret_V_2_fu_95_p2;\nwire   [0:0] ret_V_3_fu_101_p2;\nwire   [0:0] ret_V_4_fu_113_p2;\nwire   [0:0] ret_V_5_fu_119_p2;\nwire   [0:0] ret_V_6_fu_125_p2;\nwire   [0:0] ret_V_7_fu_131_p2;\nwire   [0:0] ret_V_8_fu_143_p2;\nwire   [0:0] ret_V_9_fu_149_p2;\nwire   [0:0] ret_V_10_fu_155_p2;\nwire   [0:0] ret_V_11_fu_161_p2;\nwire   [0:0] ret_V_12_fu_173_p2;\nwire   [0:0] ret_V_13_fu_179_p2;\nwire   [0:0] ret_V_14_fu_185_p2;\nwire   [0:0] ret_V_15_fu_191_p2;\nwire   [0:0] ret_V_16_fu_203_p2;\nwire   [0:0] ret_V_17_fu_209_p2;\nwire   [0:0] ret_V_18_fu_215_p2;\nwire   [0:0] ret_V_19_fu_221_p2;\n\nassign r_V_1_fu_107_p2 = (b ^ 1'd1);\n\nassign r_V_2_fu_137_p2 = (c ^ 1'd1);\n\nassign r_V_3_fu_167_p2 = (d ^ 1'd1);\n\nassign r_V_4_fu_197_p2 = (e ^ 1'd1);\n\nassign r_V_fu_77_p2 = (1'd1 ^ a);\n\nassign ret_V_10_fu_155_p2 = (r_V_2_fu_137_p2 ^ d);\n\nassign ret_V_11_fu_161_p2 = (r_V_2_fu_137_p2 ^ e);\n\nassign ret_V_12_fu_173_p2 = (r_V_3_fu_167_p2 ^ a);\n\nassign ret_V_13_fu_179_p2 = (r_V_3_fu_167_p2 ^ b);\n\nassign ret_V_14_fu_185_p2 = (r_V_3_fu_167_p2 ^ c);\n\nassign ret_V_15_fu_191_p2 = (r_V_3_fu_167_p2 ^ e);\n\nassign ret_V_16_fu_203_p2 = (r_V_4_fu_197_p2 ^ a);\n\nassign ret_V_17_fu_209_p2 = (r_V_4_fu_197_p2 ^ b);\n\nassign ret_V_18_fu_215_p2 = (r_V_4_fu_197_p2 ^ c);\n\nassign ret_V_19_fu_221_p2 = (r_V_4_fu_197_p2 ^ d);\n\nassign ret_V_1_fu_89_p2 = (r_V_fu_77_p2 ^ c);\n\nassign ret_V_2_fu_95_p2 = (r_V_fu_77_p2 ^ d);\n\nassign ret_V_3_fu_101_p2 = (r_V_fu_77_p2 ^ e);\n\nassign ret_V_4_fu_113_p2 = (r_V_1_fu_107_p2 ^ a);\n\nassign ret_V_5_fu_119_p2 = (r_V_1_fu_107_p2 ^ c);\n\nassign ret_V_6_fu_125_p2 = (r_V_1_fu_107_p2 ^ d);\n\nassign ret_V_7_fu_131_p2 = (r_V_1_fu_107_p2 ^ e);\n\nassign ret_V_8_fu_143_p2 = (r_V_2_fu_137_p2 ^ a);\n\nassign ret_V_9_fu_149_p2 = (r_V_2_fu_137_p2 ^ b);\n\nassign ret_V_fu_83_p2 = (r_V_fu_77_p2 ^ b);\n\nassign out_r = {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{1'd1}, {ret_V_fu_83_p2}}}, {ret_V_1_fu_89_p2}}}, {ret_V_2_fu_95_p2}}}, {ret_V_3_fu_101_p2}}}, {ret_V_4_fu_113_p2}}}, {1'd1}}}, {ret_V_5_fu_119_p2}}}, {ret_V_6_fu_125_p2}}}, {ret_V_7_fu_131_p2}}}, {ret_V_8_fu_143_p2}}}, {ret_V_9_fu_149_p2}}}, {1'd1}}}, {ret_V_10_fu_155_p2}}}, {ret_V_11_fu_161_p2}}}, {ret_V_12_fu_173_p2}}}, {ret_V_13_fu_179_p2}}}, {ret_V_14_fu_185_p2}}}, {1'd1}}}, {ret_V_15_fu_191_p2}}}, {ret_V_16_fu_203_p2}}}, {ret_V_17_fu_209_p2}}}, {ret_V_18_fu_215_p2}}}, {ret_V_19_fu_221_p2}}}, {1'd1}};\n\nendmodule //vector5", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a, b, c, d, e\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d,e} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic e;\n\tlogic [24:0] out_ref;\n\tlogic [24:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.out(out_ref) );\n\t\t\n\tvector5 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "popcount3", "prompt": "module popcount3 (\n        in_r,\n        out_r\n);\n\n\ninput  [2:0] in_r;\noutput  [1:0] out_r;", "canonical_solution": "wire   [0:0] trunc_ln779_fu_47_p1;\nwire   [0:0] tmp_fu_55_p3;\nwire   [0:0] tmp_1_fu_67_p3;\nwire   [1:0] zext_ln214_fu_75_p1;\nwire   [1:0] zext_ln5_1_fu_63_p1;\nwire   [1:0] add_ln214_fu_79_p2;\nwire   [1:0] zext_ln5_fu_51_p1;\n\nassign add_ln214_fu_79_p2 = (zext_ln214_fu_75_p1 + zext_ln5_1_fu_63_p1);\n\nassign tmp_1_fu_67_p3 = in_r[32'd2];\n\nassign tmp_fu_55_p3 = in_r[32'd1];\n\nassign trunc_ln779_fu_47_p1 = in_r[0:0];\n\nassign zext_ln214_fu_75_p1 = tmp_1_fu_67_p3;\n\nassign zext_ln5_1_fu_63_p1 = tmp_fu_55_p3;\n\nassign zext_ln5_fu_51_p1 = trunc_ln779_fu_47_p1;\n\nassign out_r = (add_ln214_fu_79_p2 + zext_ln5_fu_51_p1);\n\nendmodule //popcount3", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n\tassign out = in[0]+in[1]+in[2];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [2:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\tin <= 7;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\t\trepeat(9) @(posedge clk) in <= in + 1'b1;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] in;\n\tlogic [1:0] out_ref;\n\tlogic [1:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tpopcount3 top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "a2012_q1g", "prompt": "module a2012_q1g (\n        x,\n        f\n);\n\n\ninput  [4:0] x;\noutput  [0:0] f;", "canonical_solution": "wire   [0:0] icmp_ln5_fu_49_p2;\nwire   [0:0] icmp_ln5_1_fu_55_p2;\nwire   [0:0] icmp_ln5_2_fu_61_p2;\nwire   [0:0] icmp_ln5_3_fu_67_p2;\nwire   [0:0] or_ln5_1_fu_79_p2;\nwire   [0:0] or_ln5_fu_73_p2;\n\n\nassign or_ln5_1_fu_79_p2 = (icmp_ln5_3_fu_67_p2 | icmp_ln5_2_fu_61_p2);\n\nassign or_ln5_fu_73_p2 = (icmp_ln5_fu_49_p2 | icmp_ln5_1_fu_55_p2);\n\nassign f = (or_ln5_fu_73_p2 | or_ln5_1_fu_79_p2);\n\nassign icmp_ln5_1_fu_55_p2 = ((x == 5'd6) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_2_fu_61_p2 = ((x == 5'd11) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_3_fu_67_p2 = ((x == 5'd14) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_fu_49_p2 = ((x == 5'd1) ? 1'b1 : 1'b0);\n\nendmodule //a2012_q1g", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [4:0] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [4:0] x\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tx <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_f;\n\t\tint errortime_f;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [4:0] x;\n\tlogic f_ref;\n\tlogic f_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x );\n\treference_module good1 (\n\t\t.x,\n\t\t.f(f_ref) );\n\t\t\n\ta2012_q1g top_module1 (\n\t\t.x,\n\t\t.f(f_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_f) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"f\", stats1.errors_f, stats1.errortime_f);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"f\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { f_ref } === ( { f_ref } ^ { f_dut } ^ { f_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (f_ref !== ( f_ref ^ f_dut ^ f_ref ))\n\t\tbegin if (stats1.errors_f == 0) stats1.errortime_f = $time;\n\t\t\tstats1.errors_f = stats1.errors_f+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "notgate", "prompt": "module notgate (\n        in_r,\n        out_r\n);\n\n\ninput  [0:0] in_r;\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = (in_r ^ 1'd1);\n\nendmodule //notgate", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput in,\n\toutput out\n);\n\t\n\tassign out = ~in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tin <= 1'b0;\n\t\twavedrom_start(\"Inversion\");\n\t\trepeat(20) @(posedge clk)\n\t\t\tin <= $random;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\tnotgate top_module1 (\n\t\t.in_r(in),\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "review2015_fsmonehot", "prompt": "module review2015_fsmonehot (\n        d,\n        done_counting,\n        ack,\n        state,\n        B3_next,\n        S_next,\n        S1_next,\n        Count_next,\n        Wait_next,\n        done,\n        counting,\n        shift_ena\n);\n\n\ninput  [0:0] d;\ninput  [0:0] done_counting;\ninput  [0:0] ack;\ninput  [9:0] state;\noutput  [0:0] B3_next;\noutput  [0:0] S_next;\noutput  [0:0] S1_next;\noutput  [0:0] Count_next;\noutput  [0:0] Wait_next;\noutput  [0:0] done;\noutput  [0:0] counting;\noutput  [0:0] shift_ena;", "canonical_solution": "wire   [0:0] xor_ln214_fu_153_p2;\nwire   [0:0] icmp_ln1019_1_fu_161_p2;\nwire   [0:0] xor_ln901_fu_168_p2;\nwire   [0:0] and_ln19_fu_188_p2;\nwire   [6:0] tmp_fu_201_p4;\nwire   [0:0] icmp_ln1031_fu_211_p2;\nwire   [0:0] icmp_ln1039_fu_217_p2;\n\nassign and_ln19_fu_188_p2 = (icmp_ln1019_1_fu_161_p2 & ack);\n\nassign tmp_fu_201_p4 = {{state[9:3]}};\n\nassign xor_ln214_fu_153_p2 = (d ^ 1'd1);\n\nassign xor_ln901_fu_168_p2 = (done_counting ^ 1'd1);\n\nassign B3_next = ((state == 10'd8) ? 1'b1 : 1'b0);\n\nassign Count_next = (xor_ln901_fu_168_p2 & icmp_ln1019_1_fu_161_p2);\n\nassign S1_next = xor_ln214_fu_153_p2;\n\nassign S_next = xor_ln214_fu_153_p2;\n\nassign Wait_next = (icmp_ln1019_1_fu_161_p2 & done_counting);\n\nassign counting = icmp_ln1019_1_fu_161_p2;\n\nassign done = (done_counting & and_ln19_fu_188_p2);\n\nassign icmp_ln1019_1_fu_161_p2 = ((state == 10'd512) ? 1'b1 : 1'b0);\n\nassign icmp_ln1031_fu_211_p2 = ((tmp_fu_201_p4 != 7'd0) ? 1'b1 : 1'b0);\n\nassign icmp_ln1039_fu_217_p2 = ((state < 10'd15) ? 1'b1 : 1'b0);\n\nassign shift_ena = (icmp_ln1039_fu_217_p2 & icmp_ln1031_fu_211_p2);\n\nendmodule //review2015_fsmonehot", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\t parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg d, done_counting, ack,\n\toutput reg [9:0] state,\n\tinput tb_match\n);\n\tbit failed = 0;\n\tbit fail_onehot = 0;\n\t\n\talways @(posedge clk, negedge clk)\n\t\tif (!tb_match) \n\t\t\tfailed <= 1;\n\t\n\tinitial begin\n\t\t{d, done_counting, ack} <= 3'h0;\n\t\tstate <= 10'h0;\n\t\t\n\t\trepeat(300) @(posedge clk, negedge clk) begin\n\t\t\t{d, done_counting, ack} = $random;\n\t\t\tstate <= 1<< ($unsigned($random) % 10);\n\t\tend\n\n\t\t@(posedge clk) fail_onehot <= failed;\n\n\t\trepeat(3000) @(posedge clk, negedge clk) begin\n\t\t\t{d, done_counting, ack} = $random;\n\t\t\tstate <= $random;\n\t\tend\n\n\t\t\n\t\t@(posedge clk);\n\t\tif (!fail_onehot && failed) begin\n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with random inputs.\");\n\t\t\t$display (\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_B3_next;\n\t\tint errortime_B3_next;\n\t\tint errors_S_next;\n\t\tint errortime_S_next;\n\t\tint errors_S1_next;\n\t\tint errortime_S1_next;\n\t\tint errors_Count_next;\n\t\tint errortime_Count_next;\n\t\tint errors_Wait_next;\n\t\tint errortime_Wait_next;\n\t\tint errors_done;\n\t\tint errortime_done;\n\t\tint errors_counting;\n\t\tint errortime_counting;\n\t\tint errors_shift_ena;\n\t\tint errortime_shift_ena;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic d;\n\tlogic done_counting;\n\tlogic ack;\n\tlogic [9:0] state;\n\tlogic B3_next_ref;\n\tlogic B3_next_dut;\n\tlogic S_next_ref;\n\tlogic S_next_dut;\n\tlogic S1_next_ref;\n\tlogic S1_next_dut;\n\tlogic Count_next_ref;\n\tlogic Count_next_dut;\n\tlogic Wait_next_ref;\n\tlogic Wait_next_dut;\n\tlogic done_ref;\n\tlogic done_dut;\n\tlogic counting_ref;\n\tlogic counting_dut;\n\tlogic shift_ena_ref;\n\tlogic shift_ena_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n        end\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state );\n\treference_module good1 (\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state,\n\t\t.B3_next(B3_next_ref),\n\t\t.S_next(S_next_ref),\n\t\t.S1_next(S1_next_ref),\n\t\t.Count_next(Count_next_ref),\n\t\t.Wait_next(Wait_next_ref),\n\t\t.done(done_ref),\n\t\t.counting(counting_ref),\n\t\t.shift_ena(shift_ena_ref) );\n\t\t\n\treview2015_fsmonehot top_module1 (\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state,\n\t\t.B3_next(B3_next_dut),\n\t\t.S_next(S_next_dut),\n\t\t.S1_next(S1_next_dut),\n\t\t.Count_next(Count_next_dut),\n\t\t.Wait_next(Wait_next_dut),\n\t\t.done(done_dut),\n\t\t.counting(counting_dut),\n\t\t.shift_ena(shift_ena_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_B3_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"B3_next\", stats1.errors_B3_next, stats1.errortime_B3_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"B3_next\");\n\t\tif (stats1.errors_S_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"S_next\", stats1.errors_S_next, stats1.errortime_S_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"S_next\");\n\t\tif (stats1.errors_S1_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"S1_next\", stats1.errors_S1_next, stats1.errortime_S1_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"S1_next\");\n\t\tif (stats1.errors_Count_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Count_next\", stats1.errors_Count_next, stats1.errortime_Count_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Count_next\");\n\t\tif (stats1.errors_Wait_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Wait_next\", stats1.errors_Wait_next, stats1.errortime_Wait_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Wait_next\");\n\t\tif (stats1.errors_done) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"done\", stats1.errors_done, stats1.errortime_done);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"done\");\n\t\tif (stats1.errors_counting) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"counting\", stats1.errors_counting, stats1.errortime_counting);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"counting\");\n\t\tif (stats1.errors_shift_ena) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"shift_ena\", stats1.errors_shift_ena, stats1.errortime_shift_ena);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"shift_ena\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } === ( { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } ^ { B3_next_dut, S_next_dut, S1_next_dut, Count_next_dut, Wait_next_dut, done_dut, counting_dut, shift_ena_dut } ^ { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (B3_next_ref !== ( B3_next_ref ^ B3_next_dut ^ B3_next_ref ))\n\t\tbegin if (stats1.errors_B3_next == 0) stats1.errortime_B3_next = $time;\n\t\t\tstats1.errors_B3_next = stats1.errors_B3_next+1'b1; end\n\t\tif (S_next_ref !== ( S_next_ref ^ S_next_dut ^ S_next_ref ))\n\t\tbegin if (stats1.errors_S_next == 0) stats1.errortime_S_next = $time;\n\t\t\tstats1.errors_S_next = stats1.errors_S_next+1'b1; end\n\t\tif (S1_next_ref !== ( S1_next_ref ^ S1_next_dut ^ S1_next_ref ))\n\t\tbegin if (stats1.errors_S1_next == 0) stats1.errortime_S1_next = $time;\n\t\t\tstats1.errors_S1_next = stats1.errors_S1_next+1'b1; end\n\t\tif (Count_next_ref !== ( Count_next_ref ^ Count_next_dut ^ Count_next_ref ))\n\t\tbegin if (stats1.errors_Count_next == 0) stats1.errortime_Count_next = $time;\n\t\t\tstats1.errors_Count_next = stats1.errors_Count_next+1'b1; end\n\t\tif (Wait_next_ref !== ( Wait_next_ref ^ Wait_next_dut ^ Wait_next_ref ))\n\t\tbegin if (stats1.errors_Wait_next == 0) stats1.errortime_Wait_next = $time;\n\t\t\tstats1.errors_Wait_next = stats1.errors_Wait_next+1'b1; end\n\t\tif (done_ref !== ( done_ref ^ done_dut ^ done_ref ))\n\t\tbegin if (stats1.errors_done == 0) stats1.errortime_done = $time;\n\t\t\tstats1.errors_done = stats1.errors_done+1'b1; end\n\t\tif (counting_ref !== ( counting_ref ^ counting_dut ^ counting_ref ))\n\t\tbegin if (stats1.errors_counting == 0) stats1.errortime_counting = $time;\n\t\t\tstats1.errors_counting = stats1.errors_counting+1'b1; end\n\t\tif (shift_ena_ref !== ( shift_ena_ref ^ shift_ena_dut ^ shift_ena_ref ))\n\t\tbegin if (stats1.errors_shift_ena == 0) stats1.errortime_shift_ena = $time;\n\t\t\tstats1.errors_shift_ena = stats1.errors_shift_ena+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "conditional", "prompt": "module conditional (\n        a,\n        b,\n        c,\n        d,\n        min\n);\n\n\ninput  [7:0] a;\ninput  [7:0] b;\ninput  [7:0] c;\ninput  [7:0] d;\noutput  [7:0] min;", "canonical_solution": "wire   [0:0] icmp_ln1027_fu_65_p2;\nwire   [7:0] select_ln6_fu_71_p3;\nwire   [0:0] icmp_ln1027_1_fu_79_p2;\nwire   [7:0] select_ln7_fu_85_p3;\nwire   [0:0] icmp_ln1027_2_fu_93_p2;\n\nassign select_ln6_fu_71_p3 = ((icmp_ln1027_fu_65_p2[0:0] == 1'b1) ? b : a);\n\nassign select_ln7_fu_85_p3 = ((icmp_ln1027_1_fu_79_p2[0:0] == 1'b1) ? c : select_ln6_fu_71_p3);\n\nassign icmp_ln1027_1_fu_79_p2 = ((select_ln6_fu_71_p3 > c) ? 1'b1 : 1'b0);\n\nassign icmp_ln1027_2_fu_93_p2 = ((select_ln7_fu_85_p3 > d) ? 1'b1 : 1'b0);\n\nassign icmp_ln1027_fu_65_p2 = ((b < a) ? 1'b1 : 1'b0);\n\nassign min = ((icmp_ln1027_2_fu_93_p2[0:0] == 1'b1) ? d : select_ln7_fu_85_p3);\n\nendmodule //conditional", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n \tinitial begin\n \t\t{a,b,c,d} <= {8'h1, 8'h2, 8'h3, 8'h4};\n \t\t@(negedge clk);\n \t\twavedrom_start();\n\t \t\t@(posedge clk) {a,b,c,d} <= {8'h1, 8'h2, 8'h3, 8'h4};\n\t \t\t@(posedge clk) {a,b,c,d} <= {8'h11, 8'h2, 8'h3, 8'h4};\n\t \t\t@(posedge clk) {a,b,c,d} <= {8'h11, 8'h12, 8'h3, 8'h4};\n\t \t\t@(posedge clk) {a,b,c,d} <= {8'h11, 8'h12, 8'h13, 8'h4};\n\t \t\t@(posedge clk) {a,b,c,d} <= {8'h11, 8'h12, 8'h13, 8'h14};\n \t\t@(negedge clk);\n \t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_min;\n\t\tint errortime_min;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] a;\n\tlogic [7:0] b;\n\tlogic [7:0] c;\n\tlogic [7:0] d;\n\tlogic [7:0] min_ref;\n\tlogic [7:0] min_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.min(min_ref) );\n\t\t\n\tconditional top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.min(min_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_min) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"min\", stats1.errors_min, stats1.errortime_min);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"min\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { min_ref } === ( { min_ref } ^ { min_dut } ^ { min_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (min_ref !== ( min_ref ^ min_dut ^ min_ref ))\n\t\tbegin if (stats1.errors_min == 0) stats1.errortime_min = $time;\n\t\t\tstats1.errors_min = stats1.errors_min+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "a7420", "prompt": "module a7420 (\n        p1a,\n        p1b,\n        p1c,\n        p1d,\n        p1y,\n        p2a,\n        p2b,\n        p2c,\n        p2d,\n        p2y\n);\n\n\ninput  [0:0] p1a;\ninput  [0:0] p1b;\ninput  [0:0] p1c;\ninput  [0:0] p1d;\n output  [0:0] p1y;\ninput  [0:0] p2a;\ninput  [0:0] p2b;\ninput  [0:0] p2c;\ninput  [0:0] p2d;\noutput  [0:0] p2y;", "canonical_solution": "wire   [0:0] and_ln1497_1_fu_107_p2;\nwire   [0:0] and_ln1497_fu_101_p2;\nwire   [0:0] and_ln1497_4_fu_125_p2;\nwire   [0:0] and_ln1497_3_fu_119_p2;\nwire   [0:0] ret_V_fu_113_p2;\nwire   [0:0] ret_V_1_fu_131_p2;\nwire   [0:0] or_ln1497_fu_137_p2;\n\nassign and_ln1497_1_fu_107_p2 = (p1d & p1c);\n\nassign and_ln1497_3_fu_119_p2 = (p2b & p2a);\n\nassign and_ln1497_4_fu_125_p2 = (p2d & p2c);\n\nassign and_ln1497_fu_101_p2 = (p1b & p1a);\n\nassign or_ln1497_fu_137_p2 = (ret_V_fu_113_p2 | ret_V_1_fu_131_p2);\n\nassign ret_V_1_fu_131_p2 = (and_ln1497_4_fu_125_p2 & and_ln1497_3_fu_119_p2);\n\nassign ret_V_fu_113_p2 = (and_ln1497_fu_101_p2 & and_ln1497_1_fu_107_p2);\n\nassign p2y = (or_ln1497_fu_137_p2 ^ 1'd1);\n\nendmodule //a7420", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = ~&( {p1a, p1b, p1c, p1d} );\n\tassign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg p1a, p1b, p1c, p1d,\n\toutput reg p2a, p2b, p2c, p2d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{p1a,p1b,p1c,p1d} <= 4'h0;\t\t\n\t\t{p2a,p2b,p2c,p2d} <= 4'h0;\t\t\n\t\twavedrom_start(\"Two NAND gates\");\n\t\trepeat(20) @(posedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d} <= count;\t\t\n\t\t\t{p2a,p2b,p2c,p2d} <= count+1;\t\t\n\t\t\tcount = count + 1;\n\t\tend\n\t\twavedrom_stop();\n\n\t\trepeat(200) @(posedge clk,negedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d,p2a,p2b,p2c,p2d} <= $random;\t\t\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_p1y;\n\t\tint errortime_p1y;\n\t\tint errors_p2y;\n\t\tint errortime_p2y;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic p1a;\n\tlogic p1b;\n\tlogic p1c;\n\tlogic p1d;\n\tlogic p2a;\n\tlogic p2b;\n\tlogic p2c;\n\tlogic p2d;\n\tlogic p1y_ref;\n\tlogic p1y_dut;\n\tlogic p2y_ref;\n\tlogic p2y_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d );\n\treference_module good1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_ref),\n\t\t.p2y(p2y_ref) );\n\t\t\n\ta7420 top_module1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_dut),\n\t\t.p2y(p2y_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_p1y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p1y\", stats1.errors_p1y, stats1.errortime_p1y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p1y\");\n\t\tif (stats1.errors_p2y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p2y\", stats1.errors_p2y, stats1.errortime_p2y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p2y\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { p1y_ref, p2y_ref } === ( { p1y_ref, p2y_ref } ^ { p1y_dut, p2y_dut } ^ { p1y_ref, p2y_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (p1y_ref !== ( p1y_ref ^ p1y_dut ^ p1y_ref ))\n\t\tbegin if (stats1.errors_p1y == 0) stats1.errortime_p1y = $time;\n\t\t\tstats1.errors_p1y = stats1.errors_p1y+1'b1; end\n\t\tif (p2y_ref !== ( p2y_ref ^ p2y_dut ^ p2y_ref ))\n\t\tbegin if (stats1.errors_p2y == 0) stats1.errortime_p2y = $time;\n\t\t\tstats1.errors_p2y = stats1.errors_p2y+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "xnorgate", "prompt": "module xnorgate (\n        a,\n        b,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] xor_ln909_fu_51_p2;\n\nassign xor_ln909_fu_51_p2 = (b ^ a);\n\nassign out_r = (xor_ln909_fu_51_p2 ^ 1'd1);\n\nendmodule //xnorgate", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a^b);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b} <= 1'b0;\n\t\twavedrom_start(\"XNOR gate\");\n\t\trepeat(10) @(posedge clk)\n\t\t\t{a,b} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{b,a} <= $random;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.out(out_ref) );\n\t\t\n\txnorgate top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4f", "prompt": "module m2014_q4f (\n        in1,\n        in2,\n        out_r\n);\n\n\ninput  [0:0] in1;\ninput  [0:0] in2;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] rhs_V_fu_51_p2;\n\nassign rhs_V_fu_51_p2 = (in2 ^ 1'd1);\n\nassign out_r = (rhs_V_fu_51_p2 & in1);\n\nendmodule //m2014_q4f", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & ~in2;\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in1, in2\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{in1, in2} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in1;\n\tlogic in2;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in1,\n\t\t.in2 );\n\treference_module good1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out(out_ref) );\n\t\t\n\tm2014_q4f top_module1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "circuit6", "prompt": "module circuit6 (\n        a,\n        q\n);\n\n\ninput  [2:0] a;\noutput  [15:0] q;", "canonical_solution": "reg[15:0] q;\n\nwire   [2:0] a_read_read_fu_58_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if ((3'd7 == a_read_read_fu_58_p2)) begin\n        q = 16'd12057;\n    end else if ((3'd0 == a_read_read_fu_58_p2)) begin\n        q = 16'd4658;\n    end else if ((3'd1 == a_read_read_fu_58_p2)) begin\n        q = 16'd44768;\n    end else if ((3'd2 == a_read_read_fu_58_p2)) begin\n        q = 16'd10196;\n    end else if ((3'd3 == a_read_read_fu_58_p2)) begin\n        q = 16'd23054;\n    end else if ((3'd4 == a_read_read_fu_58_p2)) begin\n        q = 16'd8294;\n    end else if ((3'd5 == a_read_read_fu_58_p2)) begin\n        q = 16'd25806;\n    end else if ((3'd6 == a_read_read_fu_58_p2)) begin\n        q = 16'd50470;\n    end else begin\n        q = 'bx;\n    end\nend\n\nassign a_read_read_fu_58_p2 = a;\n\nendmodule //circuit6", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658;\n\t\t\t1: q = 44768;\n\t\t\t2: q = 10196;\n\t\t\t3: q = 23054;\n\t\t\t4: q = 8294;\n\t\t\t5: q = 25806;\n\t\t\t6: q = 50470;\n\t\t\t7: q = 12057;\n\t\tendcase\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [2:0] a,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a} <= 0;\n\t\t\trepeat(10) @(posedge clk,negedge clk) a <= a + 1;\n\t\twavedrom_stop();\n\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\ta <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] a;\n\tlogic [15:0] q_ref;\n\tlogic [15:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a );\n\treference_module good1 (\n\t\t.a,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit6 top_module1 (\n\t\t.a,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "ece241_2014_q3", "prompt": "module ece241_2014_q3 (\n        c,\n        d,\n        mux_in\n);\n\n\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [3:0] mux_in;", "canonical_solution": "wire   [0:0] ret_V_fu_55_p2;\nwire   [0:0] xor_ln804_fu_61_p2;\n\nassign ret_V_fu_55_p2 = (d & c);\n\nassign xor_ln804_fu_61_p2 = (ret_V_fu_55_p2 ^ 1'd1);\n\nassign mux_in = {{{{{{1'd1}, {ret_V_fu_55_p2}}}, {1'd0}}}, {xor_ln804_fu_61_p2}};\n\nendmodule //ece241_2014_q3", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{c, d} <= 0;\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) {c, d} <= 2'h0;\n\t\t\t@(posedge clk) {c, d} <= 2'h1;\n\t\t\t@(posedge clk) {c, d} <= 2'h2;\n\t\t\t@(posedge clk) {c, d} <= 2'h3;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(50) @(posedge clk, negedge clk)\n\t\t\t{c,d} <= $random;\n\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_mux_in;\n\t\tint errortime_mux_in;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic c;\n\tlogic d;\n\tlogic [3:0] mux_in_ref;\n\tlogic [3:0] mux_in_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.c,\n\t\t.d,\n\t\t.mux_in(mux_in_ref) );\n\t\t\n\tece241_2014_q3 top_module1 (\n\t\t.c,\n\t\t.d,\n\t\t.mux_in(mux_in_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_mux_in) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"mux_in\", stats1.errors_mux_in, stats1.errortime_mux_in);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"mux_in\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { mux_in_ref } === ( { mux_in_ref } ^ { mux_in_dut } ^ { mux_in_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (mux_in_ref !== ( mux_in_ref ^ mux_in_dut ^ mux_in_ref ))\n\t\tbegin if (stats1.errors_mux_in == 0) stats1.errortime_mux_in = $time;\n\t\t\tstats1.errors_mux_in = stats1.errors_mux_in+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "wire_decl", "prompt": "module wire_decl (\n        a,\n        b,\n        c,\n        d,\n        out_r,\n        out_n\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] out_r;\noutput  [0:0] out_n;", "canonical_solution": "wire   [0:0] or_ln11_fu_88_p2;\nwire   [0:0] wire1_fu_76_p2;\nwire   [0:0] wire2_fu_82_p2;\n\nassign or_ln11_fu_88_p2 = (wire2_fu_82_p2 | wire1_fu_76_p2);\n\nassign wire1_fu_76_p2 = (b & a);\n\nassign wire2_fu_82_p2 = (d & c);\n\nassign out_n = (or_ln11_fu_88_p2 ^ 1'd1);\n\nassign out_r = or_ln11_fu_88_p2;\n\nendmodule //wire_decl", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\n// hdlbits_prop {len: 5}\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\t\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a,b,c,d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b,c,d} = 4'h0;\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Exhaustive test\");\n\t\trepeat(20) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= {d,c,b,a} + 1'b1;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{a,b,c,d} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\t\tint errors_out_n;\n\t\tint errortime_out_n;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\tlogic out_n_ref;\n\tlogic out_n_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref),\n\t\t.out_n(out_n_ref) );\n\t\t\n\twire_decl top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_r(out_dut),\n\t\t.out_n(out_n_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\t\tif (stats1.errors_out_n) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_n\", stats1.errors_out_n, stats1.errortime_out_n);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_n\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref, out_n_ref } === ( { out_ref, out_n_ref } ^ { out_dut, out_n_dut } ^ { out_ref, out_n_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\t\tif (out_n_ref !== ( out_n_ref ^ out_n_dut ^ out_n_ref ))\n\t\tbegin if (stats1.errors_out_n == 0) stats1.errortime_out_n = $time;\n\t\t\tstats1.errors_out_n = stats1.errors_out_n+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "ece241_2014_q1c", "prompt": "module ece241_2014_q1c (\n        a,\n        b,\n        s,\n        overflow\n);\n\n\ninput  [7:0] a;\ninput  [7:0] b;\noutput  [7:0] s;\noutput  [0:0] overflow;", "canonical_solution": "wire   [7:0] ret_V_fu_57_p2;\nwire   [0:0] p_Result_s_fu_63_p3;\nwire   [0:0] p_Result_2_fu_79_p3;\nwire   [0:0] p_Result_1_fu_71_p3;\nwire   [0:0] xor_ln951_fu_93_p2;\nwire   [0:0] xor_ln956_fu_87_p2;\nwire   [0:0] xor_ln951_1_fu_99_p2;\n\nassign p_Result_1_fu_71_p3 = b[32'd7];\n\nassign p_Result_2_fu_79_p3 = ret_V_fu_57_p2[32'd7];\n\nassign p_Result_s_fu_63_p3 = a[32'd7];\n\nassign ret_V_fu_57_p2 = (b + a);\n\nassign xor_ln951_1_fu_99_p2 = (xor_ln951_fu_93_p2 ^ 1'd1);\n\nassign xor_ln951_fu_93_p2 = (p_Result_s_fu_63_p3 ^ p_Result_1_fu_71_p3);\n\nassign xor_ln956_fu_87_p2 = (p_Result_s_fu_63_p3 ^ p_Result_2_fu_79_p3);\n\nassign overflow = (xor_ln956_fu_87_p2 & xor_ln951_1_fu_99_p2);\n\nendmodule //ece241_2014_q1c", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    \n    wire [8:0] sum;\n    assign sum = a+b;\n    assign s = sum[7:0];\n    assign overflow = (!(a[7]^b[7])) & (a[7] != s[7]);\n    \nendmodule\n\n\nmodule stimulus_gen (\n    input clk,\n    output logic [7:0] a, b,\n    output reg[511:0] wavedrom_title,\n    output reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n    task wavedrom_start(input[511:0] title = \"\");\n    endtask\n    \n    task wavedrom_stop;\n        #1;\n    endtask\n    \n\n\n    initial begin\n        {a, b} <= 16'h0;\n        @(negedge clk) wavedrom_start();\n            @(posedge clk) {a, b} <= 16'h0;\n            @(posedge clk) {a, b} <= 16'h0070;\n            @(posedge clk) {a, b} <= 16'h7070;\n            @(posedge clk) {a, b} <= 16'h7090;\n            @(posedge clk) {a, b} <= 16'h9070;\n            @(posedge clk) {a, b} <= 16'h9090;\n            @(posedge clk) {a, b} <= 16'h90ff;\n        @(negedge clk) wavedrom_stop();\n        repeat(100) @(posedge clk, negedge clk)\n            {a,b} <= $random;\n\n        $finish;\n    end\n    \nendmodule\n\nmodule tb();\n\n    typedef struct packed {\n        int errors;\n        int errortime;\n        int errors_s;\n        int errortime_s;\n        int errors_overflow;\n        int errortime_overflow;\n\n        int clocks;\n    } stats;\n    \n    stats stats1;\n    \n    \n    wire[511:0] wavedrom_title;\n    wire wavedrom_enable;\n    int wavedrom_hide_after_time;\n    \n    reg clk=0;\n    initial forever\n        #5 clk = ~clk;\n\n    logic [7:0] a;\n    logic [7:0] b;\n    logic [7:0] s_ref;\n    logic [7:0] s_dut;\n    logic overflow_ref;\n    logic overflow_dut;\n\n    initial begin \n        $dumpfile(\"wave.vcd\");\n        //$dumpvars(1, tb);\n    end\n\n\n    wire tb_match;        // Verification\n    wire tb_mismatch = ~tb_match;\n    \n    stimulus_gen stim1 (\n        .clk,\n        .* ,\n        .a,\n        .b );\n    reference_module good1 (\n        .a,\n        .b,\n        .s(s_ref),\n        .overflow(overflow_ref) );\n        \n    ece241_2014_q1c top_module1 (\n        .a,\n        .b,\n        .s(s_dut),\n        .overflow(overflow_dut) );\n\n    \n    bit strobe = 0;\n    task wait_for_end_of_timestep;\n        repeat(5) begin\n            strobe <= !strobe;  // Try to delay until the very end of the time step.\n            @(strobe);\n        end\n    endtask\n    \n\n    final begin\n        if (stats1.errors_s) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"s\", stats1.errors_s, stats1.errortime_s);\n        else $display(\"Hint: Output '%s' has no mismatches.\", \"s\");\n        if (stats1.errors_overflow) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"overflow\", stats1.errors_overflow, stats1.errortime_overflow);\n        else $display(\"Hint: Output '%s' has no mismatches.\", \"overflow\");\n\n        $display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n        $display(\"Simulation finished at %0d ps\", $time);\n        $display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n    end\n    \n    // Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n    assign tb_match = ( { s_ref, overflow_ref } === ( { s_ref, overflow_ref } ^ { s_dut, overflow_dut } ^ { s_ref, overflow_ref } ) );\n    // Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n    // the sensitivity list of the @(strobe) process, which isn't implemented.\n    always @(posedge clk, negedge clk) begin\n\n        stats1.clocks++;\n        if (!tb_match) begin\n            if (stats1.errors == 0) stats1.errortime = $time;\n            stats1.errors++;\n        end\n        if (s_ref !== ( s_ref ^ s_dut ^ s_ref ))\n        begin if (stats1.errors_s == 0) stats1.errortime_s = $time;\n            stats1.errors_s = stats1.errors_s+1'b1; end\n        if (overflow_ref !== ( overflow_ref ^ overflow_dut ^ overflow_ref ))\n        begin if (stats1.errors_overflow == 0) stats1.errortime_overflow = $time;\n            stats1.errors_overflow = stats1.errors_overflow+1'b1; end\n\n    end\nendmodule"}
{"task_id": "m2014_q6b", "prompt": "module m2014_q6b (\n        y,\n        w,\n        Y2\n);\n\n\ninput  [2:0] y;\ninput  [0:0] w;\noutput  [0:0] Y2;", "canonical_solution": "reg[0:0] Y2;\n\nwire   [2:0] y_read_read_fu_52_p2;\nwire   [0:0] grp_fu_67_p2;\nwire    ap_ce_reg;\n\nalways @ (*) begin\n    if (((y_read_read_fu_52_p2 == 3'd1) | (y_read_read_fu_52_p2 == 3'd2))) begin\n        Y2 = w;\n    end else if ((y_read_read_fu_52_p2 == 3'd4)) begin\n        Y2 = 1'd1;\n    end else if (((y_read_read_fu_52_p2 == 3'd0) | (y_read_read_fu_52_p2 == 3'd3) | (y_read_read_fu_52_p2 == 3'd5))) begin\n        Y2 = grp_fu_67_p2;\n    end else begin\n        Y2 = 'bx;\n    end\nend\n\nassign grp_fu_67_p2 = (w ^ 1'd1);\n\nassign y_read_read_fu_52_p2 = y;\n\nendmodule //m2014_q6b", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0;\n\t\t\t4'h1: Y2 = 1'b0;\n\t\t\t4'h2: Y2 = 1'b1;\n\t\t\t4'h3: Y2 = 1'b1;\n\t\t\t4'h4: Y2 = 1'b0;\n\t\t\t4'h5: Y2 = 1'b1;\n\t\t\t4'h6: Y2 = 1'b0;\n\t\t\t4'h7: Y2 = 1'b0;\n\t\t\t4'h8: Y2 = 1'b0;\n\t\t\t4'h9: Y2 = 1'b1;\n\t\t\t4'ha: Y2 = 1'b1;\n\t\t\t4'hb: Y2 = 1'b1;\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [3:1] y,\n\toutput reg w\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{y,w} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Y2;\n\t\tint errortime_Y2;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:1] y;\n\tlogic w;\n\tlogic Y2_ref;\n\tlogic Y2_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.y,\n\t\t.w );\n\treference_module good1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_ref) );\n\t\t\n\tm2014_q6b top_module1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Y2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y2\", stats1.errors_Y2, stats1.errortime_Y2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y2\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Y2_ref } === ( { Y2_ref } ^ { Y2_dut } ^ { Y2_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Y2_ref !== ( Y2_ref ^ Y2_dut ^ Y2_ref ))\n\t\tbegin if (stats1.errors_Y2 == 0) stats1.errortime_Y2 = $time;\n\t\t\tstats1.errors_Y2 = stats1.errors_Y2+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "fadd", "prompt": "module fadd (\n        a,\n        b,\n        cin,\n        cout,\n        sum\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] cin;\noutput  [0:0] cout;\noutput  [0:0] sum;", "canonical_solution": "wire   [0:0] ret_V_5_fu_66_p2;\nwire   [0:0] ret_V_7_fu_79_p2;\nwire   [0:0] ret_V_8_fu_85_p2;\n\nassign ret_V_5_fu_66_p2 = (b ^ a);\n\nassign ret_V_7_fu_79_p2 = (b & a);\n\nassign ret_V_8_fu_85_p2 = (ret_V_5_fu_66_p2 & cin);\n\nassign cout = (ret_V_8_fu_85_p2 | ret_V_7_fu_79_p2);\n\nassign sum = (ret_V_5_fu_66_p2 ^ cin);\n\nendmodule //fadd", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a+b+cin;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,cin,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start();\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b000;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b010;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b100;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b110;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b000;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b001;\n\t\t\t@(posedge clk) {a,b,cin} <= 3'b011;\t\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{a,b,cin} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_cout;\n\t\tint errortime_cout;\n\t\tint errors_sum;\n\t\tint errortime_sum;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic cin;\n\tlogic cout_ref;\n\tlogic cout_dut;\n\tlogic sum_ref;\n\tlogic sum_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.cin );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.cin,\n\t\t.cout(cout_ref),\n\t\t.sum(sum_ref) );\n\t\t\n\tfadd top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.cin,\n\t\t.cout(cout_dut),\n\t\t.sum(sum_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_cout) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"cout\", stats1.errors_cout, stats1.errortime_cout);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"cout\");\n\t\tif (stats1.errors_sum) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"sum\", stats1.errors_sum, stats1.errortime_sum);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"sum\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { cout_ref, sum_ref } === ( { cout_ref, sum_ref } ^ { cout_dut, sum_dut } ^ { cout_ref, sum_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (cout_ref !== ( cout_ref ^ cout_dut ^ cout_ref ))\n\t\tbegin if (stats1.errors_cout == 0) stats1.errortime_cout = $time;\n\t\t\tstats1.errors_cout = stats1.errors_cout+1'b1; end\n\t\tif (sum_ref !== ( sum_ref ^ sum_dut ^ sum_ref ))\n\t\tbegin if (stats1.errors_sum == 0) stats1.errortime_sum = $time;\n\t\t\tstats1.errors_sum = stats1.errors_sum+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mt2015_q4b", "prompt": "module mt2015_q4b (\n        x,\n        y,\n        z\n);\n\n\ninput  [0:0] x;\ninput  [0:0] y;\noutput  [0:0] z;", "canonical_solution": "assign z = (y | x);\n\nendmodule //mt2015_q4b", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic x,\n\toutput logic y,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\t{x,y} <= 0;\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) {y,x} <= 0;\n\t\t\t@(posedge clk) {y,x} <= 1;\n\t\t\t@(posedge clk) {y,x} <= 2;\n\t\t\t@(posedge clk) {y,x} <= 3;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{x, y} <= $random % 4;\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x;\n\tlogic y;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, stim1.clk, tb_mismatch ,x,y,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_ref) );\n\t\t\n\tmt2015_q4b top_module1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "thermostat", "prompt": "module thermostat (\n        mode,\n        too_cold,\n        too_hot,\n        fan_on,\n        heater,\n        aircon,\n        fan\n);\n\n\ninput  [0:0] mode;\ninput  [0:0] too_cold;\ninput  [0:0] too_hot;\ninput  [0:0] fan_on;\noutput  [0:0] heater;\noutput  [0:0] aircon;\noutput  [0:0] fan;", "canonical_solution": "wire   [0:0] xor_ln8_fu_92_p2;\nwire   [0:0] too_cold_2_fu_105_p3;\n\nassign too_cold_2_fu_105_p3 = ((mode[0:0] == 1'b1) ? too_cold : too_hot);\n\nassign xor_ln8_fu_92_p2 = (mode ^ 1'd1);\n\nassign aircon = (xor_ln8_fu_92_p2 & too_hot);\n\nassign fan = (too_cold_2_fu_105_p3 | fan_on);\n\nassign heater = (too_cold & mode);\n\nendmodule //thermostat", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\t\n\tassign fan = (mode ? too_cold : too_hot) | fan_on;\n\tassign heater = (mode & too_cold);\n\tassign aircon = (~mode & too_hot);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg too_cold, too_hot, mode, fan_on,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{too_cold, too_hot, mode, fan_on} <= 4'b0010;\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Winter\");\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0010;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0010;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1010;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1011;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0010;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0011;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0010;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0110;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1110;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0111;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1111;\n\t\t@(negedge clk) wavedrom_stop();\n\n\t\t{too_cold, too_hot, mode, fan_on} <= 4'b0000;\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Summer\");\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0000;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0000;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0100;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0101;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0000;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0001;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b0000;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1000;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1100;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1001;\n\t\t\t@(posedge clk) {too_cold, too_hot, mode, fan_on} <= 4'b1101;\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200)\n\t\t\t@(posedge clk, negedge clk) {too_cold, too_hot, mode, fan_on} <= $random;\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_heater;\n\t\tint errortime_heater;\n\t\tint errors_aircon;\n\t\tint errortime_aircon;\n\t\tint errors_fan;\n\t\tint errortime_fan;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic mode;\n\tlogic too_cold;\n\tlogic too_hot;\n\tlogic fan_on;\n\tlogic heater_ref;\n\tlogic heater_dut;\n\tlogic aircon_ref;\n\tlogic aircon_dut;\n\tlogic fan_ref;\n\tlogic fan_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.mode,\n\t\t.too_cold,\n\t\t.too_hot,\n\t\t.fan_on );\n\treference_module good1 (\n\t\t.mode,\n\t\t.too_cold,\n\t\t.too_hot,\n\t\t.fan_on,\n\t\t.heater(heater_ref),\n\t\t.aircon(aircon_ref),\n\t\t.fan(fan_ref) );\n\t\t\n\tthermostat top_module1 (\n\t\t.mode,\n\t\t.too_cold,\n\t\t.too_hot,\n\t\t.fan_on,\n\t\t.heater(heater_dut),\n\t\t.aircon(aircon_dut),\n\t\t.fan(fan_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_heater) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"heater\", stats1.errors_heater, stats1.errortime_heater);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"heater\");\n\t\tif (stats1.errors_aircon) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"aircon\", stats1.errors_aircon, stats1.errortime_aircon);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"aircon\");\n\t\tif (stats1.errors_fan) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"fan\", stats1.errors_fan, stats1.errortime_fan);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"fan\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { heater_ref, aircon_ref, fan_ref } === ( { heater_ref, aircon_ref, fan_ref } ^ { heater_dut, aircon_dut, fan_dut } ^ { heater_ref, aircon_ref, fan_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (heater_ref !== ( heater_ref ^ heater_dut ^ heater_ref ))\n\t\tbegin if (stats1.errors_heater == 0) stats1.errortime_heater = $time;\n\t\t\tstats1.errors_heater = stats1.errors_heater+1'b1; end\n\t\tif (aircon_ref !== ( aircon_ref ^ aircon_dut ^ aircon_ref ))\n\t\tbegin if (stats1.errors_aircon == 0) stats1.errortime_aircon = $time;\n\t\t\tstats1.errors_aircon = stats1.errors_aircon+1'b1; end\n\t\tif (fan_ref !== ( fan_ref ^ fan_dut ^ fan_ref ))\n\t\tbegin if (stats1.errors_fan == 0) stats1.errortime_fan = $time;\n\t\t\tstats1.errors_fan = stats1.errors_fan+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "m2014_q4e", "prompt": "module m2014_q4e (\n        in1,\n        in2,\n        out_r\n);\n\n\ninput  [0:0] in1;\ninput  [0:0] in2;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] ret_V_fu_51_p2;\n\nassign ret_V_fu_51_p2 = (in2 | in1);\n\nassign out_r = (ret_V_fu_51_p2 ^ 1'd1);\n\nendmodule //m2014_q4e", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in1, in2\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{in1, in2} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in1;\n\tlogic in2;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in1,\n\t\t.in2 );\n\treference_module good1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out(out_ref) );\n\t\t\n\tm2014_q4e top_module1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mux256to1", "prompt": "module mux256to1 (\n        in_r,\n        sel,\n        out_r\n);\n\n\ninput  [255:0] in_r;\ninput  [7:0] sel;\noutput  [0:0] out_r;", "canonical_solution": "wire   [9:0] Lo_fu_65_p3;\nwire   [9:0] Hi_fu_73_p2;\nwire   [0:0] icmp_ln628_fu_79_p2;\nwire   [9:0] sub_ln628_fu_95_p2;\nwire   [9:0] sub_ln628_1_fu_107_p2;\nreg   [1023:0] tmp_fu_85_p4;\nwire   [9:0] xor_ln628_fu_101_p2;\nwire   [9:0] select_ln628_fu_113_p3;\nwire   [9:0] select_ln628_2_fu_129_p3;\nwire   [9:0] xor_ln628_1_fu_137_p2;\nwire   [1023:0] select_ln628_1_fu_121_p3;\nwire   [1023:0] zext_ln628_fu_143_p1;\nwire   [1023:0] zext_ln628_1_fu_147_p1;\nwire   [1023:0] lshr_ln628_fu_151_p2;\nwire   [1023:0] lshr_ln628_1_fu_157_p2;\nwire   [1023:0] p_Result_s_fu_163_p2;\n\nassign Hi_fu_73_p2 = (10'd3 | Lo_fu_65_p3);\n\nassign Lo_fu_65_p3 = {{sel}, {2'd0}};\n\nassign lshr_ln628_1_fu_157_p2 = 1024'd179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137215 >> zext_ln628_1_fu_147_p1;\n\nassign lshr_ln628_fu_151_p2 = select_ln628_1_fu_121_p3 >> zext_ln628_fu_143_p1;\n\nassign p_Result_s_fu_163_p2 = (lshr_ln628_fu_151_p2 & lshr_ln628_1_fu_157_p2);\n\nassign select_ln628_1_fu_121_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? tmp_fu_85_p4 : in_r);\n\nassign select_ln628_2_fu_129_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? xor_ln628_fu_101_p2 : Lo_fu_65_p3);\n\nassign select_ln628_fu_113_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? sub_ln628_fu_95_p2 : sub_ln628_1_fu_107_p2);\n\nassign sub_ln628_1_fu_107_p2 = (Hi_fu_73_p2 - Lo_fu_65_p3);\n\nassign sub_ln628_fu_95_p2 = (Lo_fu_65_p3 - Hi_fu_73_p2);\n\ninteger ap_tvar_int_0;\n\nalways @ (in_r) begin\n    for (ap_tvar_int_0 = 1024 - 1; ap_tvar_int_0 >= 0; ap_tvar_int_0 = ap_tvar_int_0 - 1) begin\n        if (ap_tvar_int_0 > 1023 - 0) begin\n            tmp_fu_85_p4[ap_tvar_int_0] = 1'b0;\n        end else begin\n            tmp_fu_85_p4[ap_tvar_int_0] = in_r[1023 - ap_tvar_int_0];\n        end\n    end\nend\n\nassign xor_ln628_1_fu_137_p2 = (select_ln628_fu_113_p3 ^ 10'd1023);\n\nassign xor_ln628_fu_101_p2 = (10'd1023 ^ Lo_fu_65_p3);\n\nassign zext_ln628_1_fu_147_p1 = xor_ln628_1_fu_137_p2;\n\nassign zext_ln628_fu_143_p1 = select_ln628_2_fu_129_p3;\n\nassign icmp_ln628_fu_79_p2 = ((Lo_fu_65_p3 > Hi_fu_73_p2) ? 1'b1 : 1'b0);\n\nassign out_r = p_Result_s_fu_163_p2[3:0];\n\nendmodule //mux256to1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [255:0] in,\n\toutput logic [7:0] sel\n);\n\n\talways @(posedge clk, negedge clk) begin\n\t\tfor (int i=0;i<8; i++)\n\t\t\tin[i*8+:32] <= $random;\n\t\tsel <= $random;\n\tend\n\t\n\tinitial begin\n\t\trepeat(1000) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [255:0] in;\n\tlogic [7:0] sel;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.sel );\n\treference_module good1 (\n\t\t.in,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\tmux256to1 top_module1 (\n\t\t.in_r(in),\n\t\t.sel,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "a2012_q2b", "prompt": "module a2012_q2b (\n        y,\n        w,\n        Y1,\n        Y3\n);\n\n\ninput  [5:0] y;\ninput  [0:0] w;\noutput  [0:0] Y1;\noutput  [0:0] Y3;", "canonical_solution": "wire   [0:0] or_ln7_fu_70_p2;\nwire   [0:0] icmp_ln1019_fu_58_p2;\nwire   [0:0] icmp_ln1019_1_fu_64_p2;\nwire   [0:0] icmp_ln8_fu_77_p2;\n\n\nassign or_ln7_fu_70_p2 = (icmp_ln1019_fu_58_p2 | icmp_ln1019_1_fu_64_p2);\n\nassign Y1 = or_ln7_fu_70_p2;\n\nassign Y3 = (or_ln7_fu_70_p2 | icmp_ln8_fu_77_p2);\n\nassign icmp_ln1019_1_fu_64_p2 = ((y == 6'd32) ? 1'b1 : 1'b0);\n\nassign icmp_ln1019_fu_58_p2 = ((y == 6'd16) ? 1'b1 : 1'b0);\n\nassign icmp_ln8_fu_77_p2 = ((y == 6'd4) ? 1'b1 : 1'b0);\n\nendmodule //a2012_q2b", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\tassign Y1 = y[0]&w;\n\tassign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w;\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic[5:0] y,\n\toutput logic w,\n\tinput tb_match\n);\n\n\tint errored1 = 0;\n\tint onehot_error = 0;\n\tint temp;\n\t\n\tinitial begin\n\t\t// Test the one-hot cases first.\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\ty <= 1<< ($unsigned($random) % 6);\n\t\t\tw <= $random;\n\t\t\tif (!tb_match) onehot_error++;\n\t\tend\n\t\t\t\n\t\t\t\n\t\t// Random.\n\t\terrored1 = 0;\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tdo \n\t\t\t\ttemp = $random;\n\t\t\twhile ( !{temp[5:4],temp[2:1]} == !{temp[3],temp[0]} );\t\n\t\t\t// Make y[3,0] and y[5,4,2,1] mutually exclusive, so we can accept Y3=(~y[3] & ~y[0]) &~w as a valid answer too.\n\n\t\t\ty <= temp;\n\t\t\tw <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored1++;\n\t\tend\n\t\tif (!onehot_error && errored1) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with semi-random inputs.\");\n\n\t\tif (!onehot_error && errored1)\n\t\t\t$display(\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Y1;\n\t\tint errortime_Y1;\n\t\tint errors_Y3;\n\t\tint errortime_Y3;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [5:0] y;\n\tlogic w;\n\tlogic Y1_ref;\n\tlogic Y1_dut;\n\tlogic Y3_ref;\n\tlogic Y3_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.y,\n\t\t.w );\n\treference_module good1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y1(Y1_ref),\n\t\t.Y3(Y3_ref) );\n\t\t\n\ta2012_q2b top_module1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y1(Y1_dut),\n\t\t.Y3(Y3_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Y1) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y1\", stats1.errors_Y1, stats1.errortime_Y1);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y1\");\n\t\tif (stats1.errors_Y3) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y3\", stats1.errors_Y3, stats1.errortime_Y3);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y3\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Y1_ref, Y3_ref } === ( { Y1_ref, Y3_ref } ^ { Y1_dut, Y3_dut } ^ { Y1_ref, Y3_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Y1_ref !== ( Y1_ref ^ Y1_dut ^ Y1_ref ))\n\t\tbegin if (stats1.errors_Y1 == 0) stats1.errortime_Y1 = $time;\n\t\t\tstats1.errors_Y1 = stats1.errors_Y1+1'b1; end\n\t\tif (Y3_ref !== ( Y3_ref ^ Y3_dut ^ Y3_ref ))\n\t\tbegin if (stats1.errors_Y3 == 0) stats1.errortime_Y3 = $time;\n\t\t\tstats1.errors_Y3 = stats1.errors_Y3+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mux2to1", "prompt": "module mux2to1 (\n        a,\n        b,\n        sel,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] sel;\noutput  [0:0] out_r;", "canonical_solution": "assign out_r = ((sel[0:0] == 1'b1) ? b : a);\n\nendmodule //mux2to1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,sel,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a, b, sel} <= 3'b000;\n\t\t@(negedge clk) wavedrom_start(\"<b>Sel</b> chooses between <b>a</b> and <b>b</b>\");\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b000;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b100;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b110;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b111;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b011;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b001;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b100;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b101;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b110;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b111;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic sel;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\tmux2to1 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mux256to1v", "prompt": "module mux256to1v (\n        in_r,\n        sel,\n        out_r\n);\n\n\ninput  [1023:0] in_r;\ninput  [7:0] sel;\noutput  [3:0] out_r;", "canonical_solution": "wire   [9:0] Lo_fu_65_p3;\nwire   [9:0] Hi_fu_73_p2;\nwire   [0:0] icmp_ln628_fu_79_p2;\nwire   [9:0] sub_ln628_fu_95_p2;\nwire   [9:0] sub_ln628_1_fu_107_p2;\nreg   [1023:0] tmp_fu_85_p4;\nwire   [9:0] xor_ln628_fu_101_p2;\nwire   [9:0] select_ln628_fu_113_p3;\nwire   [9:0] select_ln628_2_fu_129_p3;\nwire   [9:0] xor_ln628_1_fu_137_p2;\nwire   [1023:0] select_ln628_1_fu_121_p3;\nwire   [1023:0] zext_ln628_fu_143_p1;\nwire   [1023:0] zext_ln628_1_fu_147_p1;\nwire   [1023:0] lshr_ln628_fu_151_p2;\nwire   [1023:0] lshr_ln628_1_fu_157_p2;\nwire   [1023:0] p_Result_s_fu_163_p2;\n\nassign Hi_fu_73_p2 = (10'd3 | Lo_fu_65_p3);\n\nassign Lo_fu_65_p3 = {{sel}, {2'd0}};\n\nassign lshr_ln628_1_fu_157_p2 = 1024'd179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137215 >> zext_ln628_1_fu_147_p1;\n\nassign lshr_ln628_fu_151_p2 = select_ln628_1_fu_121_p3 >> zext_ln628_fu_143_p1;\n\nassign p_Result_s_fu_163_p2 = (lshr_ln628_fu_151_p2 & lshr_ln628_1_fu_157_p2);\n\nassign select_ln628_1_fu_121_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? tmp_fu_85_p4 : in_r);\n\nassign select_ln628_2_fu_129_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? xor_ln628_fu_101_p2 : Lo_fu_65_p3);\n\nassign select_ln628_fu_113_p3 = ((icmp_ln628_fu_79_p2[0:0] == 1'b1) ? sub_ln628_fu_95_p2 : sub_ln628_1_fu_107_p2);\n\nassign sub_ln628_1_fu_107_p2 = (Hi_fu_73_p2 - Lo_fu_65_p3);\n\nassign sub_ln628_fu_95_p2 = (Lo_fu_65_p3 - Hi_fu_73_p2);\n\ninteger ap_tvar_int_0;\n\nalways @ (in_r) begin\n    for (ap_tvar_int_0 = 1024 - 1; ap_tvar_int_0 >= 0; ap_tvar_int_0 = ap_tvar_int_0 - 1) begin\n        if (ap_tvar_int_0 > 1023 - 0) begin\n            tmp_fu_85_p4[ap_tvar_int_0] = 1'b0;\n        end else begin\n            tmp_fu_85_p4[ap_tvar_int_0] = in_r[1023 - ap_tvar_int_0];\n        end\n    end\nend\n\nassign xor_ln628_1_fu_137_p2 = (select_ln628_fu_113_p3 ^ 10'd1023);\n\nassign xor_ln628_fu_101_p2 = (10'd1023 ^ Lo_fu_65_p3);\n\nassign zext_ln628_1_fu_147_p1 = xor_ln628_1_fu_137_p2;\n\nassign zext_ln628_fu_143_p1 = select_ln628_2_fu_129_p3;\n\nassign icmp_ln628_fu_79_p2 = ((Lo_fu_65_p3 > Hi_fu_73_p2) ? 1'b1 : 1'b0);\n\nassign out_r = p_Result_s_fu_163_p2[3:0];\n\nendmodule //mux256to1v", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\tassign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [1023:0] in,\n\toutput logic [7:0] sel\n);\n\n\talways @(posedge clk, negedge clk) begin\n\t\tfor (int i=0;i<32; i++)\n\t\t\tin[i*32+:32] <= $random;\n\t\tsel <= $random;\n\tend\n\t\n\tinitial begin\n\t\trepeat(1000) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [1023:0] in;\n\tlogic [7:0] sel;\n\tlogic [3:0] out_ref;\n\tlogic [3:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.sel );\n\treference_module good1 (\n\t\t.in,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\tmux256to1v top_module1 (\n\t\t.in_r(in),\n\t\t.sel,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "hadd", "prompt": "module hadd (\n        a,\n        b,\n        sum,\n        cout\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\noutput  [0:0] sum;\noutput  [0:0] cout;", "canonical_solution": "assign cout = (b & a);\n\nassign sum = (b ^ a);\n\nendmodule //hadd", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a+b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b\n);\n\n\talways @(posedge clk, negedge clk)\n\t\t{a,b} <= $random;\n\t\n\tinitial begin\n\t\trepeat(100) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_sum;\n\t\tint errortime_sum;\n\t\tint errors_cout;\n\t\tint errortime_cout;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic sum_ref;\n\tlogic sum_dut;\n\tlogic cout_ref;\n\tlogic cout_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sum(sum_ref),\n\t\t.cout(cout_ref) );\n\t\t\n\thadd top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sum(sum_dut),\n\t\t.cout(cout_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_sum) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"sum\", stats1.errors_sum, stats1.errortime_sum);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"sum\");\n\t\tif (stats1.errors_cout) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"cout\", stats1.errors_cout, stats1.errortime_cout);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"cout\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { sum_ref, cout_ref } === ( { sum_ref, cout_ref } ^ { sum_dut, cout_dut } ^ { sum_ref, cout_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (sum_ref !== ( sum_ref ^ sum_dut ^ sum_ref ))\n\t\tbegin if (stats1.errors_sum == 0) stats1.errortime_sum = $time;\n\t\t\tstats1.errors_sum = stats1.errors_sum+1'b1; end\n\t\tif (cout_ref !== ( cout_ref ^ cout_dut ^ cout_ref ))\n\t\tbegin if (stats1.errors_cout == 0) stats1.errortime_cout = $time;\n\t\t\tstats1.errors_cout = stats1.errors_cout+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mux9to1v", "prompt": "module mux9to1v (\n        a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        sel,\n        out_r\n);\n\n\ninput  [15:0] a;\ninput  [15:0] b;\ninput  [15:0] c;\ninput  [15:0] d;\ninput  [15:0] e;\ninput  [15:0] f;\ninput  [15:0] g;\ninput  [15:0] h;\ninput  [15:0] i;\ninput  [3:0] sel;\noutput  [15:0] out_r;", "canonical_solution": "wire   [0:0] icmp_ln5_8_fu_183_p2;\nwire   [0:0] icmp_ln5_7_fu_177_p2;\nwire   [0:0] icmp_ln5_6_fu_171_p2;\nwire   [0:0] icmp_ln5_5_fu_165_p2;\nwire   [0:0] icmp_ln5_4_fu_159_p2;\nwire   [0:0] icmp_ln5_3_fu_153_p2;\nwire   [0:0] icmp_ln5_2_fu_147_p2;\nwire   [0:0] icmp_ln5_1_fu_141_p2;\nwire   [0:0] icmp_ln5_fu_135_p2;\nwire   [0:0] or_ln5_fu_197_p2;\nwire   [15:0] select_ln5_fu_189_p3;\nwire   [15:0] select_ln5_1_fu_203_p3;\nwire   [0:0] or_ln5_1_fu_211_p2;\nwire   [0:0] or_ln5_2_fu_225_p2;\nwire   [15:0] select_ln5_2_fu_217_p3;\nwire   [15:0] select_ln5_3_fu_231_p3;\nwire   [0:0] or_ln5_3_fu_239_p2;\nwire   [0:0] or_ln5_4_fu_261_p2;\nwire   [15:0] select_ln5_5_fu_253_p3;\nwire   [15:0] select_ln5_6_fu_267_p3;\nwire   [0:0] or_ln5_5_fu_275_p2;\nwire   [0:0] or_ln5_6_fu_289_p2;\nwire   [15:0] select_ln5_7_fu_281_p3;\nwire   [15:0] select_ln5_4_fu_245_p3;\nwire    ap_ce_reg;\n\nassign icmp_ln5_fu_135_p2 = ((sel == 4'd8) ? 1'b1 : 1'b0);\n\nassign or_ln5_1_fu_211_p2 = (icmp_ln5_6_fu_171_p2 | icmp_ln5_5_fu_165_p2);\n\nassign or_ln5_2_fu_225_p2 = (icmp_ln5_4_fu_159_p2 | icmp_ln5_3_fu_153_p2);\n\nassign or_ln5_3_fu_239_p2 = (icmp_ln5_2_fu_147_p2 | icmp_ln5_1_fu_141_p2);\n\nassign or_ln5_4_fu_261_p2 = (or_ln5_fu_197_p2 | or_ln5_1_fu_211_p2);\n\nassign or_ln5_5_fu_275_p2 = (or_ln5_3_fu_239_p2 | or_ln5_2_fu_225_p2);\n\nassign or_ln5_6_fu_289_p2 = (or_ln5_5_fu_275_p2 | or_ln5_4_fu_261_p2);\n\nassign or_ln5_fu_197_p2 = (icmp_ln5_8_fu_183_p2 | icmp_ln5_7_fu_177_p2);\n\nassign select_ln5_1_fu_203_p3 = ((icmp_ln5_6_fu_171_p2[0:0] == 1'b1) ? c : d);\n\nassign select_ln5_2_fu_217_p3 = ((icmp_ln5_4_fu_159_p2[0:0] == 1'b1) ? e : f);\n\nassign select_ln5_3_fu_231_p3 = ((icmp_ln5_2_fu_147_p2[0:0] == 1'b1) ? g : h);\n\nassign select_ln5_4_fu_245_p3 = ((icmp_ln5_fu_135_p2[0:0] == 1'b1) ? i : 16'd65535);\n\nassign select_ln5_5_fu_253_p3 = ((or_ln5_fu_197_p2[0:0] == 1'b1) ? select_ln5_fu_189_p3 : select_ln5_1_fu_203_p3);\n\nassign select_ln5_6_fu_267_p3 = ((or_ln5_2_fu_225_p2[0:0] == 1'b1) ? select_ln5_2_fu_217_p3 : select_ln5_3_fu_231_p3);\n\nassign select_ln5_7_fu_281_p3 = ((or_ln5_4_fu_261_p2[0:0] == 1'b1) ? select_ln5_5_fu_253_p3 : select_ln5_6_fu_267_p3);\n\nassign select_ln5_fu_189_p3 = ((icmp_ln5_8_fu_183_p2[0:0] == 1'b1) ? a : b);\n\nassign icmp_ln5_1_fu_141_p2 = ((sel == 4'd7) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_2_fu_147_p2 = ((sel == 4'd6) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_3_fu_153_p2 = ((sel == 4'd5) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_4_fu_159_p2 = ((sel == 4'd4) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_5_fu_165_p2 = ((sel == 4'd3) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_6_fu_171_p2 = ((sel == 4'd2) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_7_fu_177_p2 = ((sel == 4'd1) ? 1'b1 : 1'b0);\n\nassign icmp_ln5_8_fu_183_p2 = ((sel == 4'd0) ? 1'b1 : 1'b0);\n\nassign out_r = ((or_ln5_6_fu_289_p2[0:0] == 1'b1) ? select_ln5_7_fu_281_p3 : select_ln5_4_fu_245_p3);\n\nendmodule //mux9to1v", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [15:0] a,b,c,d,e,f,g,h,i,\n\toutput logic [3:0] sel,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\t\n\t\n\tinitial begin\n\t\t{a,b,c,d,e,f,g,h,i,sel} <= { 16'ha, 16'hb, 16'hc, 16'hd, 16'he, 16'hf, 16'h11, 16'h12, 16'h13, 4'h0 };\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) sel <= 4'h1;\n\t\t\t@(posedge clk) sel <= 4'h2;\n\t\t\t@(posedge clk) sel <= 4'h3;\n\t\t\t@(posedge clk) sel <= 4'h4;\n\t\t\t@(posedge clk) sel <= 4'h7;\n\t\t\t@(posedge clk) sel <= 4'h8;\n\t\t\t@(posedge clk) sel <= 4'h9;\n\t\t\t@(posedge clk) sel <= 4'ha;\n\t\t\t@(posedge clk) sel <= 4'hb;\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\t\n\t\trepeat(200) @(negedge clk, posedge clk) begin\n\t\t\t{a,b,c,d,e,f,g,h,i,sel} <= {$random, $random, $random, $random, $random};\n\t\tend\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [15:0] a;\n\tlogic [15:0] b;\n\tlogic [15:0] c;\n\tlogic [15:0] d;\n\tlogic [15:0] e;\n\tlogic [15:0] f;\n\tlogic [15:0] g;\n\tlogic [15:0] h;\n\tlogic [15:0] i;\n\tlogic [3:0] sel;\n\tlogic [15:0] out_ref;\n\tlogic [15:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.f,\n\t\t.g,\n\t\t.h,\n\t\t.i,\n\t\t.sel );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.f,\n\t\t.g,\n\t\t.h,\n\t\t.i,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\tmux9to1v top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.f,\n\t\t.g,\n\t\t.h,\n\t\t.i,\n\t\t.sel,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vectorgates", "prompt": "module vectorgates (\n        a,\n        b,\n        out_or_bitwise,\n        out_or_logical,\n        out_not\n);\n\n\ninput  [2:0] a;\ninput  [2:0] b;\noutput  [2:0] out_or_bitwise;\noutput  [0:0] out_or_logical;\noutput  [5:0] out_not;", "canonical_solution": "wire   [2:0] ret_V_fu_77_p2;\nwire   [2:0] r_V_fu_91_p2;\nwire   [2:0] r_V_2_fu_97_p2;\n\nassign r_V_2_fu_97_p2 = (3'd7 ^ a);\n\nassign r_V_fu_91_p2 = (b ^ 3'd7);\n\nassign ret_V_fu_77_p2 = (b | a);\n\nassign out_not = {{r_V_fu_91_p2}, {r_V_2_fu_97_p2}};\n\nassign out_or_bitwise = ret_V_fu_77_p2;\n\nassign out_or_logical = ((ret_V_fu_77_p2 != 3'd0) ? 1'b1 : 1'b0);\n\nendmodule //vectorgates", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [2:0] a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 6'h38;\n\t\t{b, a} <= 6'b0;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\trepeat(30) @(posedge clk)\n\t\t\t{b, a} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{b,a} <= $random;\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_or_bitwise;\n\t\tint errortime_out_or_bitwise;\n\t\tint errors_out_or_logical;\n\t\tint errortime_out_or_logical;\n\t\tint errors_out_not;\n\t\tint errortime_out_not;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] a;\n\tlogic [2:0] b;\n\tlogic [2:0] out_or_bitwise_ref;\n\tlogic [2:0] out_or_bitwise_dut;\n\tlogic out_or_logical_ref;\n\tlogic out_or_logical_dut;\n\tlogic [5:0] out_not_ref;\n\tlogic [5:0] out_not_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_or_bitwise(out_or_bitwise_ref),\n\t\t.out_or_logical(out_or_logical_ref),\n\t\t.out_not(out_not_ref) );\n\t\t\n\tvectorgates top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.out_or_bitwise(out_or_bitwise_dut),\n\t\t.out_or_logical(out_or_logical_dut),\n\t\t.out_not(out_not_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_or_bitwise) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or_bitwise\", stats1.errors_out_or_bitwise, stats1.errortime_out_or_bitwise);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or_bitwise\");\n\t\tif (stats1.errors_out_or_logical) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or_logical\", stats1.errors_out_or_logical, stats1.errortime_out_or_logical);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or_logical\");\n\t\tif (stats1.errors_out_not) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_not\", stats1.errors_out_not, stats1.errortime_out_not);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_not\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_or_bitwise_ref, out_or_logical_ref, out_not_ref } === ( { out_or_bitwise_ref, out_or_logical_ref, out_not_ref } ^ { out_or_bitwise_dut, out_or_logical_dut, out_not_dut } ^ { out_or_bitwise_ref, out_or_logical_ref, out_not_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_or_bitwise_ref !== ( out_or_bitwise_ref ^ out_or_bitwise_dut ^ out_or_bitwise_ref ))\n\t\tbegin if (stats1.errors_out_or_bitwise == 0) stats1.errortime_out_or_bitwise = $time;\n\t\t\tstats1.errors_out_or_bitwise = stats1.errors_out_or_bitwise+1'b1; end\n\t\tif (out_or_logical_ref !== ( out_or_logical_ref ^ out_or_logical_dut ^ out_or_logical_ref ))\n\t\tbegin if (stats1.errors_out_or_logical == 0) stats1.errortime_out_or_logical = $time;\n\t\t\tstats1.errors_out_or_logical = stats1.errors_out_or_logical+1'b1; end\n\t\tif (out_not_ref !== ( out_not_ref ^ out_not_dut ^ out_not_ref ))\n\t\tbegin if (stats1.errors_out_not == 0) stats1.errortime_out_not = $time;\n\t\t\tstats1.errors_out_not = stats1.errors_out_not+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "mt2015_q4", "prompt": "module mt2015_q4 (\n        x,\n        y,\n        z\n);\n\n\ninput  [0:0] x;\ninput  [0:0] y;\noutput  [0:0] z;", "canonical_solution": "assign z = 1'd0;\n\nendmodule //mt2015_q4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x|~y;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic x,\n\toutput logic y\n);\n\n\talways @(posedge clk, negedge clk)\n\t\t{x, y} <= $random % 4;\n\t\n\tinitial begin\n\t\trepeat(100) @(negedge clk);\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x;\n\tlogic y;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_ref) );\n\t\t\n\tmt2015_q4 top_module1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "kmap2", "prompt": "module kmap2 (\n        a,\n        b,\n        c,\n        d,\n        out_r\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] out_r;", "canonical_solution": "wire   [0:0] lhs_V_fu_67_p2;\nwire   [0:0] or_ln5_fu_79_p2;\nwire   [0:0] ret_V_fu_73_p2;\nwire   [0:0] xor_ln5_fu_85_p2;\nwire   [0:0] or_ln1498_fu_91_p2;\nwire   [0:0] and_ln1497_fu_103_p2;\nwire   [0:0] or_ln1498_1_fu_109_p2;\nwire   [0:0] and_ln1498_1_fu_115_p2;\nwire   [0:0] and_ln1498_fu_97_p2;\n\nassign and_ln1497_fu_103_p2 = (d & c);\n\nassign and_ln1498_1_fu_115_p2 = (or_ln1498_1_fu_109_p2 & b);\n\nassign and_ln1498_fu_97_p2 = (or_ln1498_fu_91_p2 & a);\n\nassign lhs_V_fu_67_p2 = (c ^ 1'd1);\n\nassign or_ln1498_1_fu_109_p2 = (xor_ln5_fu_85_p2 | and_ln1497_fu_103_p2);\n\nassign or_ln1498_fu_91_p2 = (xor_ln5_fu_85_p2 | ret_V_fu_73_p2);\n\nassign or_ln5_fu_79_p2 = (d | c);\n\nassign ret_V_fu_73_p2 = (lhs_V_fu_67_p2 & d);\n\nassign xor_ln5_fu_85_p2 = (or_ln5_fu_79_p2 ^ 1'd1);\n\nassign out_r = (and_ln1498_fu_97_p2 | and_ln1498_1_fu_115_p2);\n\nendmodule //kmap2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&d);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c,d} <= 4'b0;\n\t\twavedrom_start();\n\t\trepeat(16) @(posedge clk)\n\t\t\t{a,b,c,d} <= count++;\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref) );\n\t\t\n\tkmap2 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_r(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "vector1", "prompt": "module vector1 (\n        in_r,\n        out_hi,\n        out_lo\n);\n\n\ninput  [15:0] in_r;\noutput  [7:0] out_hi;\noutput  [7:0] out_lo;", "canonical_solution": "assign out_hi = {{in_r[15:8]}};\n\nassign out_lo = in_r[7:0];\n\nendmodule //vector1", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign {out_hi, out_lo} = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [15:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\talways @(posedge clk, negedge clk)\n\t\tin <= $random;\n\t\n\tinitial begin\n\t\twavedrom_start(\"Random inputs\");\n\t\trepeat(10) @(posedge clk);\n\t\twavedrom_stop();\n\t\trepeat(100) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_hi;\n\t\tint errortime_out_hi;\n\t\tint errors_out_lo;\n\t\tint errortime_out_lo;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [15:0] in;\n\tlogic [7:0] out_hi_ref;\n\tlogic [7:0] out_hi_dut;\n\tlogic [7:0] out_lo_ref;\n\tlogic [7:0] out_lo_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_hi(out_hi_ref),\n\t\t.out_lo(out_lo_ref) );\n\t\t\n\tvector1 top_module1 (\n\t\t.in_r(in),\n\t\t.out_hi(out_hi_dut),\n\t\t.out_lo(out_lo_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_hi) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_hi\", stats1.errors_out_hi, stats1.errortime_out_hi);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_hi\");\n\t\tif (stats1.errors_out_lo) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_lo\", stats1.errors_out_lo, stats1.errortime_out_lo);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_lo\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_hi_ref, out_lo_ref } === ( { out_hi_ref, out_lo_ref } ^ { out_hi_dut, out_lo_dut } ^ { out_hi_ref, out_lo_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_hi_ref !== ( out_hi_ref ^ out_hi_dut ^ out_hi_ref ))\n\t\tbegin if (stats1.errors_out_hi == 0) stats1.errortime_out_hi = $time;\n\t\t\tstats1.errors_out_hi = stats1.errors_out_hi+1'b1; end\n\t\tif (out_lo_ref !== ( out_lo_ref ^ out_lo_dut ^ out_lo_ref ))\n\t\tbegin if (stats1.errors_out_lo == 0) stats1.errortime_out_lo = $time;\n\t\t\tstats1.errors_out_lo = stats1.errors_out_lo+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "circuit4", "prompt": "module circuit4 (\n        a,\n        b,\n        c,\n        d,\n        q\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] q;", "canonical_solution": "wire   [0:0] xor_ln6_fu_67_p2;\nwire   [0:0] or_ln6_fu_73_p2;\nwire   [0:0] xor_ln6_1_fu_85_p2;\nwire   [0:0] xor_ln6_2_fu_97_p2;\nwire   [0:0] and_ln6_3_fu_109_p2;\nwire   [0:0] and_ln6_2_fu_103_p2;\nwire   [0:0] and_ln6_1_fu_91_p2;\nwire   [0:0] and_ln6_4_fu_115_p2;\nwire   [0:0] or_ln6_1_fu_121_p2;\nwire   [0:0] and_ln6_fu_79_p2;\n\nassign and_ln6_1_fu_91_p2 = (xor_ln6_1_fu_85_p2 & c);\n\nassign and_ln6_2_fu_103_p2 = (xor_ln6_2_fu_97_p2 & a);\n\nassign and_ln6_3_fu_109_p2 = (d & c);\n\nassign and_ln6_4_fu_115_p2 = (and_ln6_3_fu_109_p2 & and_ln6_2_fu_103_p2);\n\nassign and_ln6_fu_79_p2 = (xor_ln6_fu_67_p2 & b);\n\nassign or_ln6_1_fu_121_p2 = (and_ln6_4_fu_115_p2 | and_ln6_1_fu_91_p2);\n\nassign or_ln6_fu_73_p2 = (b | a);\n\nassign xor_ln6_1_fu_85_p2 = (or_ln6_fu_73_p2 ^ 1'd1);\n\nassign xor_ln6_2_fu_97_p2 = (b ^ 1'd1);\n\nassign xor_ln6_fu_67_p2 = (1'd1 ^ a);\n\nassign q = (or_ln6_1_fu_121_p2 | and_ln6_fu_79_p2);\n\nendmodule //circuit4", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,c,d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b,c,d} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b,c,d} <= 0;\n\t\t\trepeat(18) @(posedge clk, negedge clk) {a,b,c,d} <= {a,b,c,d} + 1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_ref) );\n\t\t\n\tcircuit4 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "reduction", "prompt": "module reduction (\n        in_r,\n        parity\n);\n\n\ninput  [7:0] in_r;\noutput  [0:0] parity;", "canonical_solution": "wire   [0:0] tmp_fu_61_p3;\nwire   [0:0] trunc_ln5_fu_57_p1;\nwire   [0:0] tmp_1_fu_69_p3;\nwire   [0:0] tmp_2_fu_77_p3;\nwire   [0:0] xor_ln214_2_fu_123_p2;\nwire   [0:0] xor_ln214_1_fu_117_p2;\nwire   [0:0] tmp_3_fu_85_p3;\nwire   [0:0] tmp_4_fu_93_p3;\nwire   [0:0] tmp_5_fu_101_p3;\nwire   [0:0] tmp_6_fu_109_p3;\nwire   [0:0] xor_ln214_5_fu_141_p2;\nwire   [0:0] xor_ln214_4_fu_135_p2;\nwire   [0:0] xor_ln214_6_fu_147_p2;\nwire   [0:0] xor_ln214_3_fu_129_p2;\n\nassign tmp_1_fu_69_p3 = in_r[32'd2];\n\nassign tmp_2_fu_77_p3 = in_r[32'd3];\n\nassign tmp_3_fu_85_p3 = in_r[32'd4];\n\nassign tmp_4_fu_93_p3 = in_r[32'd5];\n\nassign tmp_5_fu_101_p3 = in_r[32'd6];\n\nassign tmp_6_fu_109_p3 = in_r[32'd7];\n\nassign tmp_fu_61_p3 = in_r[32'd1];\n\nassign trunc_ln5_fu_57_p1 = in_r[0:0];\n\nassign xor_ln214_1_fu_117_p2 = (trunc_ln5_fu_57_p1 ^ tmp_fu_61_p3);\n\nassign xor_ln214_2_fu_123_p2 = (tmp_2_fu_77_p3 ^ tmp_1_fu_69_p3);\n\nassign xor_ln214_3_fu_129_p2 = (xor_ln214_2_fu_123_p2 ^ xor_ln214_1_fu_117_p2);\n\nassign xor_ln214_4_fu_135_p2 = (tmp_4_fu_93_p3 ^ tmp_3_fu_85_p3);\n\nassign xor_ln214_5_fu_141_p2 = (tmp_6_fu_109_p3 ^ tmp_5_fu_101_p3);\n\nassign xor_ln214_6_fu_147_p2 = (xor_ln214_5_fu_141_p2 ^ xor_ln214_4_fu_135_p2);\n\nassign parity = (xor_ln214_6_fu_147_p2 ^ xor_ln214_3_fu_129_p2);\n\nendmodule //reduction", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_parity;\n\t\tint errortime_parity;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic parity_ref;\n\tlogic parity_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.parity(parity_ref) );\n\t\t\n\treduction top_module1 (\n\t\t.in_r(in),\n\t\t.parity(parity_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_parity) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"parity\", stats1.errors_parity, stats1.errortime_parity);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"parity\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { parity_ref } === ( { parity_ref } ^ { parity_dut } ^ { parity_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (parity_ref !== ( parity_ref ^ parity_dut ^ parity_ref ))\n\t\tbegin if (stats1.errors_parity == 0) stats1.errortime_parity = $time;\n\t\t\tstats1.errors_parity = stats1.errors_parity+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "zero", "prompt": "module zero (\n        zero_r\n);\n\n\noutput  [0:0] zero_r;", "canonical_solution": "assign zero_r = 1'd0;\n\nendmodule //zero", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start(\"Output should 0\");\n\t\trepeat(20) @(posedge clk, negedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_zero;\n\t\tint errortime_zero;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic zero_ref;\n\tlogic zero_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.*  );\n\treference_module good1 (\n\t\t.zero(zero_ref) );\n\t\t\n\tzero top_module1 (\n\t\t.zero_r(zero_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_zero) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"zero\", stats1.errors_zero, stats1.errortime_zero);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"zero\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { zero_ref } === ( { zero_ref } ^ { zero_dut } ^ { zero_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (zero_ref !== ( zero_ref ^ zero_dut ^ zero_ref ))\n\t\tbegin if (stats1.errors_zero == 0) stats1.errortime_zero = $time;\n\t\t\tstats1.errors_zero = stats1.errors_zero+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "ece241_2013_q2", "prompt": "module ece241_2013_q2 (\n        a,\n        b,\n        c,\n        d,\n        out_sop,\n        out_pos\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] c;\ninput  [0:0] d;\noutput  [0:0] out_sop;\noutput  [0:0] out_pos;", "canonical_solution": "wire   [0:0] or_ln1497_fu_76_p2;\nwire   [0:0] or_ln1497_1_fu_82_p2;\nwire   [0:0] xor_ln1497_fu_88_p2;\nwire   [0:0] ret_V_6_fu_100_p2;\nwire   [0:0] and_ln1497_fu_112_p2;\nwire   [0:0] xor_ln7_fu_106_p2;\nwire   [0:0] or_ln1497_2_fu_124_p2;\nwire   [0:0] xor_ln1497_1_fu_130_p2;\nwire   [0:0] ret_V_fu_94_p2;\nwire   [0:0] ret_V_1_fu_136_p2;\nwire   [0:0] or_ln1498_fu_142_p2;\nwire   [0:0] and_ln1497_1_fu_118_p2;\nwire   [0:0] and_ln1497_3_fu_161_p2;\nwire   [0:0] ret_V_4_fu_167_p2;\nwire   [0:0] ret_V_7_fu_155_p2;\n\nassign and_ln1497_1_fu_118_p2 = (xor_ln7_fu_106_p2 & and_ln1497_fu_112_p2);\n\nassign and_ln1497_3_fu_161_p2 = (b & a);\n\nassign and_ln1497_fu_112_p2 = (d & c);\n\nassign or_ln1497_1_fu_82_p2 = (or_ln1497_fu_76_p2 | b);\n\nassign or_ln1497_2_fu_124_p2 = (or_ln1497_fu_76_p2 | a);\n\nassign or_ln1497_fu_76_p2 = (d | c);\n\nassign or_ln1498_fu_142_p2 = (ret_V_fu_94_p2 | ret_V_1_fu_136_p2);\n\nassign ret_V_1_fu_136_p2 = (xor_ln1497_1_fu_130_p2 & b);\n\nassign ret_V_4_fu_167_p2 = (and_ln1497_fu_112_p2 & and_ln1497_3_fu_161_p2);\n\nassign ret_V_6_fu_100_p2 = (b | a);\n\nassign ret_V_7_fu_155_p2 = (ret_V_6_fu_100_p2 | or_ln1497_fu_76_p2);\n\nassign ret_V_fu_94_p2 = (xor_ln1497_fu_88_p2 & a);\n\nassign xor_ln1497_1_fu_130_p2 = (or_ln1497_2_fu_124_p2 ^ 1'd1);\n\nassign xor_ln1497_fu_88_p2 = (or_ln1497_1_fu_82_p2 ^ 1'd1);\n\nassign xor_ln7_fu_106_p2 = (ret_V_6_fu_100_p2 ^ 1'd1);\n\nassign out_pos = (ret_V_7_fu_155_p2 ^ ret_V_4_fu_167_p2);\n\nassign out_sop = (or_ln1498_fu_142_p2 | and_ln1497_1_fu_118_p2);\n\nendmodule //ece241_2013_q2", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c;\n\tassign pos0 = c & (~b|d)&(~a|b);\n\tassign pos1 = c & (~b|d)&(~a|d);\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tbit fail = 0;\n\tbit fail1 = 0;\n\talways @(posedge clk, negedge clk)\n\t\tif (!tb_match)\n\t\t\tfail = 1;\n\n\tinitial begin\n\t\t@(posedge clk) {a,b,c,d} <= 0;\n\t\t@(posedge clk) {a,b,c,d} <= 1;\n\t\t@(posedge clk) {a,b,c,d} <= 2;\n\t\t@(posedge clk) {a,b,c,d} <= 4;\n\t\t@(posedge clk) {a,b,c,d} <= 5;\n\t\t@(posedge clk) {a,b,c,d} <= 6;\n\t\t@(posedge clk) {a,b,c,d} <= 7;\n\t\t@(posedge clk) {a,b,c,d} <= 9;\n\t\t@(posedge clk) {a,b,c,d} <= 10;\n\t\t@(posedge clk) {a,b,c,d} <= 13;\n\t\t@(posedge clk) {a,b,c,d} <= 14;\n\t\t@(posedge clk) {a,b,c,d} <= 15;\n\t\t@(posedge clk) fail1 = fail;\n\t\t\n\t\t\n\t\t\t\t\n\t\t\n\t\t//@(negedge clk) wavedrom_start();\n\t\t\tfor (int i=0;i<16;i++)\n\t\t\t\t@(posedge clk)\n\t\t\t\t\t{a,b,c,d} <= i;\n\t\t//@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(50) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d} <= $random;\n\t\t\t\n\t\tif (fail && ~fail1)\n\t\t\t$display(\"Hint: Your circuit passes on the 12 required input combinations, but doesn't match the don't-care cases. Are you using minimal SOP and POS?\");\n\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_sop;\n\t\tint errortime_out_sop;\n\t\tint errors_out_pos;\n\t\tint errortime_out_pos;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_sop_ref;\n\tlogic out_sop_dut;\n\tlogic out_pos_ref;\n\tlogic out_pos_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_sop(out_sop_ref),\n\t\t.out_pos(out_pos_ref) );\n\t\t\n\tece241_2013_q2 top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out_sop(out_sop_dut),\n\t\t.out_pos(out_pos_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_sop) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_sop\", stats1.errors_out_sop, stats1.errortime_out_sop);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_sop\");\n\t\tif (stats1.errors_out_pos) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_pos\", stats1.errors_out_pos, stats1.errortime_out_pos);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_pos\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_sop_ref, out_pos_ref } === ( { out_sop_ref, out_pos_ref } ^ { out_sop_dut, out_pos_dut } ^ { out_sop_ref, out_pos_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_sop_ref !== ( out_sop_ref ^ out_sop_dut ^ out_sop_ref ))\n\t\tbegin if (stats1.errors_out_sop == 0) stats1.errortime_out_sop = $time;\n\t\t\tstats1.errors_out_sop = stats1.errors_out_sop+1'b1; end\n\t\tif (out_pos_ref !== ( out_pos_ref ^ out_pos_dut ^ out_pos_ref ))\n\t\tbegin if (stats1.errors_out_pos == 0) stats1.errortime_out_pos = $time;\n\t\t\tstats1.errors_out_pos = stats1.errors_out_pos+1'b1; end\n\n\tend\nendmodule"}
{"task_id": "always_if", "prompt": "module always_if (\n        a,\n        b,\n        sel_b1,\n        sel_b2,\n        out_assign,\n        out_always\n);\n\n\ninput  [0:0] a;\ninput  [0:0] b;\ninput  [0:0] sel_b1;\ninput  [0:0] sel_b2;\noutput  [0:0] out_assign;\noutput  [0:0] out_always;", "canonical_solution": "wire   [3:0] zext_ln186_fu_104_p1;\nwire   [0:0] icmp_ln8_fu_78_p2;\nwire   [0:0] icmp_ln8_1_fu_84_p2;\nwire   [0:0] and_ln8_fu_90_p2;\nwire   [0:0] select_ln8_fu_96_p3;\n\nassign and_ln8_fu_90_p2 = (icmp_ln8_fu_78_p2 & icmp_ln8_1_fu_84_p2);\n\nassign select_ln8_fu_96_p3 = ((and_ln8_fu_90_p2[0:0] == 1'b1) ? b : a);\n\nassign zext_ln186_fu_104_p1 = select_ln8_fu_96_p3;\n\nassign icmp_ln8_1_fu_84_p2 = ((sel_b2 != 4'd0) ? 1'b1 : 1'b0);\n\nassign icmp_ln8_fu_78_p2 = ((sel_b1 != 4'd0) ? 1'b1 : 1'b0);\n\nassign out_always = zext_ln186_fu_104_p1;\n\nassign out_assign = zext_ln186_fu_104_p1;\n\nendmodule //always_if", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,sel_b1, sel_b2,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a, b, sel_b1, sel_b2} <= 4'b000;\n\t\t@(negedge clk) wavedrom_start(\"\");\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0100;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1000;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1101;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0001;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0110;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1010;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0011;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1011;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0011;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel_b1,sel_b2} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_assign;\n\t\tint errortime_out_assign;\n\t\tint errors_out_always;\n\t\tint errortime_out_always;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic sel_b1;\n\tlogic sel_b2;\n\tlogic out_assign_ref;\n\tlogic out_assign_dut;\n\tlogic out_always_ref;\n\tlogic out_always_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t//$dumpvars(1, tb);\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2 );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2,\n\t\t.out_assign(out_assign_ref),\n\t\t.out_always(out_always_ref) );\n\t\t\n\talways_if top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2,\n\t\t.out_assign(out_assign_dut),\n\t\t.out_always(out_always_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_assign) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_assign\", stats1.errors_out_assign, stats1.errortime_out_assign);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_assign\");\n\t\tif (stats1.errors_out_always) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_always\", stats1.errors_out_always, stats1.errortime_out_always);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_always\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_assign_ref, out_always_ref } === ( { out_assign_ref, out_always_ref } ^ { out_assign_dut, out_always_dut } ^ { out_assign_ref, out_always_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_assign_ref !== ( out_assign_ref ^ out_assign_dut ^ out_assign_ref ))\n\t\tbegin if (stats1.errors_out_assign == 0) stats1.errortime_out_assign = $time;\n\t\t\tstats1.errors_out_assign = stats1.errors_out_assign+1'b1; end\n\t\tif (out_always_ref !== ( out_always_ref ^ out_always_dut ^ out_always_ref ))\n\t\tbegin if (stats1.errors_out_always == 0) stats1.errortime_out_always = $time;\n\t\t\tstats1.errors_out_always = stats1.errors_out_always+1'b1; end\n\n\tend\nendmodule"}
